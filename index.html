
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>Winter Bud</title>
	<meta name="author" content="wibud">

	
	<meta name="description" content="前端 | Comments 初识react 是什么 React is a JavaScript library for creating user interfaces by Facebook and Instagram. Many people choose to think of React &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Winter Bud" type="application/atom+xml">
	
	<link rel="canonical" href="http://wibud.github.io/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="/javascripts/libs/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='/images/avator.jpeg' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>

<nav id="main-nav">
<section class="aboutme">
  <i>Winter Bud</i>
  <p>
    UED程序猿；专业前端，业余JAVA；爱鼓捣、瞎折腾；讲的了段子，写的了代码
  </p>
</section>

<ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="/about">About</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:wi_bud@163.com" title="Email">Email</a>
		
		
		
		
		
			<a class="github" href="https://github.com/wibud" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
		
			<a class="weibo" href="http://weibo.com/u/2435540027" title="weibo">Weibo</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-03-21T16:12:08+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/qian-duan/'>前端</a>


</div>
		
		
          | <a href="/blog/2015/03/21/chu-shi-react/#comments">Comments</a>
         
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/03/21/chu-shi-react/" itemprop="url">初识react</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>是什么</h2>

<blockquote><p>React is a JavaScript library for creating user interfaces by Facebook and Instagram. Many people choose to think of React as the V in MVC.</p>

<p>We built React to solve one problem: building large applications with data that changes over time. To do this, React uses two main ideas.</p></blockquote>

<p>套用官网的一句话</p>

<blockquote><p>React可以被认为是MVC中得View层。它是用来构建数据不断变化的大型发杂应用的。</p></blockquote>

<p>所以不要拿React同Angular等框架作比较了，它只是View层的框架，没有什么可比性~~</p>

<p>在React中，贯穿始终的就是<code>组件</code>（组件化也是web发展的方向），React组件可以简单的认为是HTML和JavaScript的组合，通常的View层是使用一些模板工具生成，而React是通过组件的组合产出View，每个组件都可以独立或者配合使用（组件定义良好的话），其中React提供了一系列创建组件、渲染组件的方法，同时也对事件、状态等进行了封装。</p>

<p>为什么说React适合数据频繁变化的应用呢？</p>

<ul>
<li>数据变化时，只需更新组件的状态，剩下的操作React都帮你做了</li>
<li>React创造性的虚拟DOM和diff算法，使得其比传统的DOM更新更加高效，性能也更高</li>
</ul>


<p>这里不得不提一下<a href="http://facebook.github.io/jsx/">JSX</a>，它是和React配合使用的，当然不用也可以的（follow your heart~）。</p>

<blockquote><p>JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。React 可以用来做简单的 JSX 句法转换。</p></blockquote>

<p>简单说来，JSX就是可以将JavaScript 语法写成XML/HTML的那个样子，举个简单的例子：</p>

<pre><code>// 输入 (JSX):
var app = &lt;Nav color="blue" /&gt;;
// JSX 把类 XML 的语法转成原生 JavaScript，XML 元素、属性和子节点被转换成 React.createElement 的参数。
// 经JSX转化，输出 (JS):
var app = React.createElement(Nav, {color:"blue"});
</code></pre>

<h2>为什么</h2>

<p>我是否该使用React？别急，下面我们来详细看下。</p>

<h3>优点</h3>

<ul>
<li>只需要声明怎么展示，数据变化时，React自动帮你处理，不需要关心怎么更新DOM</li>
<li>React唯一需要做的就是构建组件，组件良好的封装性，更易于代码复用和关注分离</li>
<li>只需要查看组件的返回就能知道组件是如何渲染的，而不需要知道HTML和JS处理逻辑</li>
<li>方便维护和扩展</li>
</ul>


<h3>缺点</h3>

<ul>
<li>学习成本虽然不高，但是要理解和熟练掌握还是要花一定的时间，主要是官方文档错综发杂</li>
<li>React很年轻，社区也在发展中，相应的组件库并不丰富</li>
<li>React只是View层，实现一些复杂应用可能需要其他框架的支持</li>
</ul>


<h2>怎么用</h2>

<h3>如何显示</h3>

<p>先来看一个官网上的简单例子：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Hello React&lt;/title&gt;
        &lt;script src="http://fb.me/react-0.13.0.js"&gt;&lt;/script&gt;
        &lt;script src="http://fb.me/JSXTransformer-0.13.0.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="example"&gt;&lt;/div&gt;
        &lt;script type="text/jsx"&gt;

            var HelloWorld = React.createClass({

                render: function() {
                    return (
                        &lt;p&gt;
                            Hello, &lt;input type="text" placeholder="Your name here" /&gt;!
                            It is {this.props.date.toTimeString()}
                        &lt;/p&gt;
                    );
                }
            });

            setInterval(function() {
                React.render(
                    &lt;HelloWorld date={new Date()} /&gt;,
                    document.getElementById('example')
                );
            }, 500);

        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>在浏览器中运行这个例子，时间是每隔半秒钟变化一次。在输入框输入内容，你会发现 React 在用户界面中只改变了时间， 任何你在输入框输入的内容一直保留着，React知道哪些东西改变了，知道要更新哪些东西，并且帮你做好了。</p>

<p>其中用到了JSX，使用JSX的话，需要用<code>&lt;script type="text/jsx"&gt;</code>标签包裹JSX代码。</p>

<p>对这个组件的输入称为 props - &ldquo;properties&#8221;的缩写。得益于 JSX 语法，它们通过参数传递。不要去修改props的值， this.props 是只读的。</p>

<p>React 组件非常简单。你可以认为它们就是简单的函数，接受 props 和 state (后面会讨论) 作为参数，然后渲染出 HTML。正是应为它们是这么的简单，这使得它们非常容易理解。</p>

<h3>如何交互</h3>

<p>继续上官网里例子：</p>

<pre><code>var LikeButton = React.createClass({
    getInitialState: function() {
        return {liked: false};
    },
    handleClick: function(event) {
        this.setState({liked: !this.state.liked});
    },
    render: function() {
        var text = this.state.liked ? 'like' : 'haven\'t liked';
        return (
            &lt;p onClick={this.handleClick}&gt;
                You {text} this. Click to toggle.
            &lt;/p&gt;
        );
    }
});

React.render(
    &lt;LikeButton /&gt;,
    document.getElementById('example')
);
</code></pre>

<p>在浏览器中运行这个例子，每次点击按钮，我们的文案就换了。这里我们绑定了事件，同时用到了state。</p>

<p>这里的事件绑定与处理是经过React封装过得，当然封装是透明的，用起来和原生事件一样。</p>

<p>可以把React组件想象成一个状态机，状态（state）改变时，就会重新渲染变化，让组件呈现的界面同数据保持一致，实现起来十分简单，只需要调用<code>setState</code>方法，改变this.state，然后React会帮我们根据新的状态来重新渲染（完全不用开发者操心）</p>

<h4>使用<code>setState</code>的几点注意：</h4>

<ul>
<li><p><code>setState</code>不会立即更新state，也不会立即调用render进行重新渲染，看如下的例子</p>

<pre><code>  var i = 0;

  var Counter = React.createClass({

      getInitialState: function(){

          return {count: i};
      },
      handle: function(e){

          i++;
          this.setState({count: i});
          console.log(this.state.count, 'click');
      },
      render: function() {
          console.log(this.state.count, 'render');
          return (
              &lt;p onClick={this.handle}&gt;
                  i = {this.state.count}
              &lt;/p&gt;
          );
      }
  });

  React.render(
      &lt;Counter /&gt;,
      document.getElementById('example')
  );
</code></pre>

<p>  浏览器运行这个例子，页面渲染完，控制台会打印出<code>0 "render"</code>，点击一下<p>标签，打印出<code>0 "click"</code> <code>1 "render"</code>。自己想一下，不然可以得出结论。</p></li>
<li><p><code>setState</code>是将参数合并（merge）到this.state上，而不是替换</p></li>
</ul>


<h4>使用state的几点注意：</h4>

<ul>
<li>state只属于当前组件，不可传递</li>
<li>state应该只包含那些可能改变并触发用户界面更新的数据，其他的数据应该放到props中</li>
<li>常用的模式是创建多个只负责渲染数据的无状态（stateless）组件，在它们的上层创建一个有状态（stateful）组件并把它的状态通过 props 传给子级。这个有状态的组件封装了所有用户的交互逻辑，而这些无状态组件则负责声明式地渲染数据。</li>
<li>state中只是存放一些元数据，更具其计算出的数据，不要放到state中，把计算放到render()中。</li>
</ul>


<h3>如何组合组件</h3>

<p>React的很棒的特性之一就是他的组件的可组合性</p>

<pre><code>var User = React.createClass({
    render: function() {
        return (
            &lt;div&gt;
                &lt;UserName name={this.props.name} /&gt;
            &lt;/div&gt;
        );
    }
});

var UserName = React.createClass({
    render: function() {
        return (
            &lt;p&gt;
                {this.props.name}
            &lt;/p&gt;
        );
    }
});

React.render(
    &lt;User name="wibud" /&gt;,
    document.getElementById('example')
);
</code></pre>

<p>也可以很简单的实现批量添加子组件：</p>

<pre><code>var User = React.createClass({
    render: function() {
        return (
            &lt;div&gt;
                {this.props.names.map(function(name){

                    return &lt;UserName name={name} /&gt;
                })}
            &lt;/div&gt;
        );
    }
});

var UserName = React.createClass({
    render: function() {
        return (
            &lt;p&gt;
                {this.props.name}
            &lt;/p&gt;
        );
    }
});

React.render(
    &lt;User names={['wibud','wibud2','wibud3']} /&gt;,
    document.getElementById('example')
);
</code></pre>

<p>父组件和子组件可以通过props来传递数据，其中父组件可以通过this.props.children来获取子组件。</p>

<p>值得注意的是：子组件会根据他们被渲染的顺序来更新DOM，如下两次渲染过程：</p>

<pre><code>// 第一次渲染
&lt;List&gt;
    &lt;p&gt;item 1&lt;/p&gt;
    &lt;p&gt;item 2&lt;/p&gt;
&lt;/List&gt;
// 第二次渲染
&lt;List&gt;
    &lt;p&gt;item 2&lt;/p&gt;
&lt;/List&gt;
</code></pre>

<p>直观来看，只是删除了<code>&lt;p&gt;item 1&lt;/p&gt;</code>。事实上，React 先更新第一个子级的内容，然后删除最后一个组件。如果想要保证子组件渲染的正确顺序，即上述例子中删除<code>&lt;p&gt;item 1&lt;/p&gt;</code>，只需要给子组件加上<code>key</code>参数即可：</p>

<pre><code>render: function() {
    var results = this.props.results;
    return (
        &lt;ol&gt;
            {results.map(function(result) {
                return &lt;li key={result.id}&gt;{result.text}&lt;/li&gt;;
            })}
        &lt;/ol&gt;
    );
}
</code></pre>

<h3>如何复用组件</h3>

<h4>propTypes</h4>

<p>随着应用不断变大，保证组件被正确使用变得非常有用。为此我们引入 <code>propTypes    。</code>propTypes`是用来校验props数据的正确性的，如果数据类型不正确，会抛出异常。处于性能考虑，校验只在debug模式下有效。</p>

<p>具体可校验类型，参考<a href="http://facebook.github.io/react/docs/reusable-components.html">这里</a></p>

<p>使用起来也是超级的简单：</p>

<pre><code>var MyComponent = React.createClass({
    propTypes: {
        children: React.PropTypes.element.isRequired
    },

    render: function() {
        return (
            &lt;div&gt;
                {this.props.children} // 有且仅有一个元素，否则会抛异常。
            &lt;/div&gt;
        );
    }
});
</code></pre>

<h4>Mixins</h4>

<p>组件是 React 里复用代码最佳方式，但是有时一些复杂的组件间也需要共用一些功能。React 使用 mixins 来解决这类问题。</p>

<p>如下例子，我们实现了通用的setInterval的创建和销毁</p>

<pre><code>var SetIntervalMixin = {
    // 组件Render前调用
    componentWillMount: function() {
        this.intervals = [];
    },
    setInterval: function() {
        this.intervals.push(setInterval.apply(null, arguments));
    },
    // 组件销毁时调用
    componentWillUnmount: function() {
        this.intervals.map(clearInterval);
    }
};

var TickTock = React.createClass({
    // 引用 mixin
    mixins: [SetIntervalMixin],

    getInitialState: function() {
        return {seconds: 0};
    },
    // 组件render完后调用
    componentDidMount: function() {
        this.setInterval(this.tick, 1000); // 调用 mixin 的方法
    },
    tick: function() {
        this.setState({seconds: this.state.seconds + 1});
    },
    render: function() {
        return (
            &lt;p&gt;
                React has been running for {this.state.seconds} seconds.
            &lt;/p&gt;
        );
    }
});

React.render(
    &lt;TickTock /&gt;,
    document.getElementById('example')
);
</code></pre>

<p>mixin相当于把通过mixin定义的方法属性赋到组件对象中，如果有多个mixin时，并用有多个 mixin 定义了同样的生命周期方法，即componentWillUnmount等方法（如：多个 mixin 都需要在组件销毁时做资源清理操作），所有这些生命周期方法都保证会被执行到。方法执行顺序是：首先按 mixin 引入顺序执行 mixin 里方法，最后执行组件内定义的方法。</p>

<h3>组件生命周期</h3>

<h4>组件初始化</h4>

<ul>
<li>1、getDefaultProps()</li>
<li>2、getInitialState()</li>
<li>3、componentWillMount()</li>
<li>4、render()</li>
<li>5、componentDidMount()</li>
</ul>


<h4>组件销毁</h4>

<ul>
<li>1、componentWillUnmount()</li>
</ul>


<h4>调用setState()后的更新流程</h4>

<ul>
<li>1、shouldComponentUpdate()</li>
<li>2、componentWillUpdate()</li>
<li>3、render()</li>
<li>4、componentDidUpdate()</li>
</ul>


<h3>class和style</h3>

<p>这里是针对JSX的</p>

<ul>
<li>class处理</li>
</ul>


<p>给节点设置样式时，需要用<code>className</code>，可以使用<code>React.addons.classSet</code>来设置多个class：</p>

<pre><code>render: function(){
    var classes = React.addons.classSet({
        'classOne': true,   // 需要
        'classTwo': false // 不需要
    });

    return &lt;div className={classes}&gt;&lt;/div&gt;
}
</code></pre>

<p>渲染的结果里，div元素会只有classOne这一个样式类。</p>

<ul>
<li>内联style</li>
</ul>


<p>实例如下：</p>

<pre><code>render: function(){
    var styles = {
        color: 'red',
        height: 10
    };

    return &lt;div style={styles}&gt;&lt;/div&gt;
}
</code></pre>

<h3>常用API</h3>

<ul>
<li><p>render()</p>

<ul>
<li>渲染组件</li>
<li>render方法要保持简单</li>
</ul>
</li>
<li><p>componentWillMount()</p>

<ul>
<li>render前调用，只触发一次</li>
<li>可做一些初始化的工作</li>
</ul>
</li>
<li><p>componentWillUnmount()</p>

<ul>
<li>组件销毁前调用</li>
<li>做一些清理工作</li>
</ul>
</li>
<li><p>getInitialState()</p>

<ul>
<li>设置初始的state值</li>
</ul>
</li>
<li><p>getDefaultProps()</p>

<ul>
<li>设置默认的prop值</li>
<li>用户未设置时，会去默认值</li>
</ul>
</li>
<li>setState()

<ul>
<li>更新state</li>
</ul>
</li>
</ul>


<p>更多API参见<a href="http://facebook.github.io/react/">官网</a></p>

<h3>Virtual DOM 和 Diff算法</h3>

<p>有兴趣看下面的资料汇总</p>

<h1>资料汇总</h1>

<ul>
<li><a href="http://facebook.github.io/react/">官网</a></li>
<li><a href="https://github.com/facebook/react/tree/master/docs/docs">文档教程(有一部分翻译成了中文)</a></li>
<li><a href="https://github.com/facebook/react/wiki/Complementary-Tools">Complementary Tools工具和组件</a></li>
<li>react virtual dom

<ul>
<li><a href="http://fluentconf.com/fluent2014/public/schedule/detail/32395">The Secrets of React&rsquo;s Virtual DOM</a></li>
<li><a href="http://stackoverflow.com/questions/21109361/why-is-reacts-concept-of-virtual-dom-said-to-be-more-performant-than-dirty-mode">Why is React&rsquo;s concept of Virtual DOM said to be more performant than dirty model checking?</a></li>
</ul>
</li>
<li><a href="http://calendar.perfplanet.com/2013/diff/">react diff algorithm</a></li>
<li><a href="https://github.com/flipboard/react-canvas">react-canvas</a>

<ul>
<li><a href="http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html">相关阅读</a></li>
</ul>
</li>
<li><a href="https://egghead.io/series/react-flux-architecture">React: Flux Architecture</a></li>
<li><a href="https://github.com/mhart/react-server-example">example of how to do server-side rendering with the React library</a></li>
<li><a href="http://weibo.com/reactchina">React 中文微博</a></li>
<li><a href="http://react-china.org/">React 中文社区</a></li>
<li><a href="https://www.codementor.io/reactjs/tutorial/react-vs-angularjs">react-vs-angularjs</a></li>
</ul>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-12-01T00:14:36+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/qian-duan/'>前端</a>


</div>
		
		
          | <a href="/blog/2014/12/01/dive-into-requestanimationframe/#comments">Comments</a>
         
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/12/01/dive-into-requestanimationframe/" itemprop="url">Dive Into requestAnimationFrame</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>介绍</h2>

<p>requestAnimationFrame(以下简称raf)方法，字面意思上看是：请求动画帧；较官方的解释是：通知在系统准备好绘制动画帧时调用该帧，从而为创建动画网页提供了一种更平滑更高效的方法；那通俗一点就是：告诉浏览器说 “我这里有一帧（一些操作），需要你帮我绘制（执行）一下”，“ok，没问题，我挑个合适的时机给你绘制这一帧（执行这些操作）”</p>

<p><img src="/images/private/raf-1.jpg" alt="" /></p>

<ul>
<li><p>一、浏览器的绘制（执行）时机是嘛时候</p>

<p>  首先，我们需要了解的是，页面的绘制由CPU或者GPU进行的，但是其绘制频率受限于我们的显示器的刷新频率，一般显示器的刷新频率是60HZ，所以对应于绘制频率最高就是60fps（frame per second）。于是60fps也成了检验性能的一个重要的指标，be closer be better，通常来说，在30fps到60fps之间都是可以接受的。</p>

<p>  60fps意味着我们执行每一帧的时间只有大约16.7ms（1000/60），这也是常见的使用setTimeout和setInterval实现动画时所设置的间隔时间。那对于raf来说呢，我们将绘制（执行）时机交给了浏览器自己进行判断，浏览器在合适的时机来绘制（执行）我们提供给浏览器的帧（操作）。浏览器如何决定这个合适时机的呢？（均基于chrome环境）</p>

<blockquote><p>raf最大的调用频率不会超过60fps</p></blockquote>

<p>  主观上来说，60fps已经达到了很好效果，没必要用到更快的更新频率了。貌似这一点也是chromium对于raf的设计原则之一，为了印证这一结论，特地去扒了扒chromium中raf的执行流程</p>

<p>  <img src="/images/private/chromium-request-anim-frame.png" alt="" /></p>

<p>  从流程图可以看到</p>

<pre><code>  if (animation update pending and &gt;= 16ms since last update)
      post task to anticipate next frame
  else
      post task to retry in (next_frame - now)ms
</code></pre>

<p>  如果有等待的animation更新且距离上一次更新超过16ms，则会post task，来准备下一帧，也就是说</p>

<blockquote><p>针对chrome而言，无论屏幕的刷新频率是多少，raf回调函数的执行频率不会超过60次/秒</p></blockquote>

<p>  找了大量的资料也没有找到raf回调的执行时机是如何计算的，唯一的途径只有看源码了，不过源码是C++，出了大学课堂就再没用过，全忘干净了。。。，大体看了看，貌似原理是：如果上一次raf的回调执行时间过长，那么触发下一次raf回调的时间就会缩短，反之亦然，目的是保证动画不丢帧。（如有错误，请轻拍~~）</p>

<p>  其实，raf不需要关心屏幕什么时候刷新，也并不是在屏幕刷新的时候进行绘制，而是保证在屏幕刷新间隔内不会有两个帧的绘制而导致前一个帧丢失。</p></li>
</ul>



		
		<a href="/blog/2014/12/01/dive-into-requestanimationframe/" class="more-link">Read on &rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-11-03T00:10:52+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/qian-duan/'>前端</a>


</div>
		
		
          | <a href="/blog/2014/11/03/yi-gpu-accelerated-compositing-in-chrome(gpuhe-cheng-jia-su-)/#comments">Comments</a>
         
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/11/03/yi-gpu-accelerated-compositing-in-chrome(gpuhe-cheng-jia-su-)/" itemprop="url">GPU Accelerated Compositing in Chrome（GPU加速合成）</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<blockquote><p>原文地址：<a href="http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome">http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome</a></p>

<p>作者：Tom Wiltzius, Vangelis Kokkevis &amp; the Chrome Graphics team</p>

<p>其中包含个人理解，如有出入，请轻拍！</p></blockquote>

<p>先来简单的总结下！</p>

<p>硬件（GPU）加速加速的是啥？是层的合成（layer composite），所以有些说使用translate3D打开硬件加速的说法是不恰当的，GPU加速是一直在的（在有GPU且设备的图形驱动可用的情况下），在chrome中，使用translate3D其实是使该元素拥有独立的GraphicsLayer，那拥有独立的GraphicsLayer有啥好处呢？简单来说有如下几点：</p>

<ul>
<li>每个GraphicsLayer都有一个GraphicsContext，GraphicsContext会输出该层的位图，交由GPU合成，比CPU要快</li>
<li>当需要repaint时，只需要repaint自己，不会影响到其他的GraphicsLayer。repaint完之后，只需要通过GPU同其他层合并下（composite layers）</li>
<li>对于CSS动画，不需要repaint</li>
</ul>


<p>下面简单介绍下chrome的渲染原理，详细了解可看下面译文或者直接读原文：</p>

<p>在chrome中为render服务的有4种树形结构，我们熟知的DOM树是其中之一，其他的三个分别是：</p>

<ul>
<li><p>RenderObject Tree</p>

<p>  由RenderObject构成，RenderObject同DOM树中得Node节点一一对应，RenderObject知道如何去paint（paint != draw）其对应的Node。</p></li>
<li><p>RenderLayers Tree</p>

<p>  由RenderLayer构成，RenderLayer同RenderObject是一对多的关系，满足如下条件的RenderObject拥有新的RenderLayer，而其他的RenderObject就和它的第一个拥有独立RenderLayer的父元素公用一个RenderLayer。</p>

<ul>
<li>页面的根节点的RenderObject</li>
<li>有明确的CSS定位属性（relative，absolute或者transform）</li>
<li>是透明的</li>
<li>有CSS overflow、CSS alpha遮罩（alpha mash）或者CSS reflection</li>
<li>有CSS 滤镜（fliter）</li>
<li>3D环境或者2D加速环境的canvas元素对应的RenderObject</li>
<li>video元素对应的RenderObject</li>
</ul>
</li>
<li><p>GraphicsLayers Tree</p>

<p>  由GraphicsLayer构成，GraphicsLayer同RenderLayer的关系和RenderLayer同RenderObject的关系是一样的。满足如下条件的RenderLayer会拥有新的GraphicsLayer。</p>

<ul>
<li>有3D或者perspective transform的CSS属性的层</li>
<li>使用加速视频解码的video元素的层</li>
<li>3D或者加速2D环境下的canvas元素的层</li>
<li>插件，比如flash（Layer is used for a composited plugin）</li>
<li>对opacity和transform应用了CSS动画的层</li>
<li>使用了加速CSS滤镜（filters）的层</li>
<li>有合成层后代的层</li>
<li>同合成层重叠，且在该合成层上面（z-index）渲染的层</li>
</ul>


<p>  每个GraphicsLayer都有一个GraphicsContext，GraphicsContext会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到GPU中，最后由GPU将多个位图进行合成，然后draw到屏幕上。</p>

<p>  需要注意的是</p>

<blockquote><p>GraphicsLayer是消耗内存资源的</p></blockquote>

<p>  所以说，对于像translate3D这样的hack不要过度使用，尤其是在手机上，大部分手机的显存和内存是共享的，GraphicsLayer过多导致内存占用过多的话，会使手机变卡的。</p></li>
</ul>


<p>在chrome为渲染服务的有两个进程：Render进程和GPU进程。GPU进程负责Render进程和GPU之间的命令的传递，Render进程包括主线程和合成线程，在chrome中，paint和composite放在了合成线程中。</p>


		
		<a href="/blog/2014/11/03/yi-gpu-accelerated-compositing-in-chrome(gpuhe-cheng-jia-su-)/" class="more-link">Read on &rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-01-09T15:17:48+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/js/'>js</a>, <a class='category' href='/blog/categories/qian-duan/'>前端</a>


</div>
		
		
          | <a href="/blog/2014/01/09/javascriptyan-ge-mo-shi-xiang-jie/#comments">Comments</a>
         
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/01/09/javascriptyan-ge-mo-shi-xiang-jie/" itemprop="url">JavaScript严格模式详解</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>一、简介</h2>

<p>严格模式（strict mode）是在ES5（ECMAScript 5）中引入的一种新的JavaScript运行模式，该模式下，禁止了很多JavaScript中问题较多、容易出错、影响应能的特性，目的是让JavaScript在更为严格的条件下运行，减少怪异行为和语言不合理的地方，提高编译运行性能（比如禁用with语句），增强了代码本身的安全性。</p>

<p>在ES5之前的版本是不支持严格模式的，但是严格模式有很好的向后兼容性，因为低版本标准的引擎会忽略严格模式的声明，这个会在之后进行介绍。</p>

<p>想了解各浏览器对于严格模式的支持情况戳这里<a href="http://kangax.github.io/es5-compat-table/">ECMAScript 5 compatibility table</a>，其中还统计了ES5新增特性的兼容情况。</p>

<h2>二、声明</h2>

<p>声明调用严格模式十分简单，也有些怪异，使用字符串字面量：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>之所以使用字符串字面量好处就是可以向后兼容，对于不支持严格模式的引擎，执行这条语句没有任何作用和影响。当然，如果我们使用了严格模式，那么就需要使用支持严格模式的引擎进行测试，使用低版本的引擎无法检测出严格模式下的错误。</p>

<p>声明方式有如下两种：</p>

<ul>
<li>1、声明整个脚本</li>
</ul>


<p>将<code>"use strict;"</code>在脚本文件第一行，且必须是第一行，否则严格模式将无效。</p>

<blockquote><p>在<code>"use strict;"</code>前不能有任何执行语句，即使是一个空的分号，都会使严格模式失效。</p></blockquote>

<p><code>&lt;script&gt;</code>包含的脚本块和引入的外部文件对于严格模式来说都是相互独立的，也就是说，一个脚本块或脚本文件设置成严格模式执行，并不会影响到其他的脚本块和脚本文件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;严格模式&quot;</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/script&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;正常模式&quot;</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>2、声明单个函数体</li>
</ul>


<p>单个函数的声明和整个脚本的类似，需要将<code>"use strict;"</code>放在函数体的第一行。这样该函数就会以严格模式运行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">f</span><span class="p">(){</span>
</span><span class='line'>    <span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



		
		<a href="/blog/2014/01/09/javascriptyan-ge-mo-shi-xiang-jie/" class="more-link">Read on &rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-12-20T17:52:00+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/gu-dao/'>鼓捣</a>


</div>
		
		
          | <a href="/blog/2013/12/20/octopresszhu-ti/#comments">Comments</a>
         
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/12/20/octopresszhu-ti/" itemprop="url">Octopress主题</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>在Octopress默认主题的基础上进行了一些修改，把nav移到了顶端，同时在左侧增加了展示用户信息的sidebar。当浏览器宽度小于1152时，添加了响应式的布局。</p>

<p>源码地址：<a href="https://github.com/wibud/Octopress-Theme-WinterBud">github</a></p>

<p>如果对主题感兴趣，安装方式如下：</p>

<pre><code>$ cd octopress
$ git clone git://github.com/wibud/Octopress-Theme-WinterBud.git .themes/WinterBud
$ rake install['WinterBud']
$ rake generate
</code></pre>

<p><img src="/images/private/blog-screen.png" alt="" /></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-08-05T11:12:00+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/qian-duan/'>前端</a>


</div>
		
		
          | <a href="/blog/2013/08/05/gethe-postqing-qiu/#comments">Comments</a>
         
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/08/05/gethe-postqing-qiu/" itemprop="url">GET和POST请求</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3>GET请求</h3>

<p>GET是最常见的请求类型，最常用于向服务器查询信息。如果要发送信息给服务器的话，需要将查询字符串参数追加到URL的末尾。</p>

<p>使用GET请求经常会发生一个错误，就是查询字符串参数的格式有问题。对于Javascript来说查询字符串中每个参数的名称和值都必须使用<code>encodeURIComponent()</code>进行编码，然后才能放到URL的末尾。</p>

<h3>POST请求</h3>

<p>POST通常用于向服务器发送应该被保存的数据。POST请求把数据作为请求的主体提交。POST请求的主体可以包含非常多的数据，而且格式不限。</p>

<h3>GET和POST的区别</h3>

<ul>
<li>GET只要是用来查询数据；POST主要用来提交数据</li>
<li>GET提交的数据是缀到URL末尾的，GET方式值发送HTTP消息头，没有消息体；POST的提交的数据是在消息体中</li>
<li>GET提交的数据量小，因为URL长度有限制；POST能提交大量数据</li>
<li>GET消耗的资源少；POST消耗的资源多</li>
</ul>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-08-03T11:11:00+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/js/'>js</a>, <a class='category' href='/blog/categories/qian-duan/'>前端</a>


</div>
		
		
          | <a href="/blog/2013/08/03/cookieyu-session/#comments">Comments</a>
         
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/08/03/cookieyu-session/" itemprop="url">Cookie与session</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>Cookie</h2>

<p>HTTP Cookie，通常直接叫做cookie，是在客户端用户存储会话信息的。cookie存储的信息是由服务器经HTTP头作为响应发给客户端的。例如服务器相应可能如下：</p>

<pre><code>HTTP/1.1 200 OK
Content-type:text/html
Set-Cookie:name=value
</code></pre>

<p>其中的<code>Set-Cookie</code>包含着会话信息，浏览器会存储这些会话信息，之后会为每个请求添加Cookie HTTP头，将信息发送回服务器，如下</p>

<pre><code>GET /index.html HTTP/1.1
Cookie:name=value
</code></pre>

<p>因为Cookie是存储在浏览器上，浏览器资源有限，所以Cookie的个数和大小会有限制，不同的浏览器对Cookie 的限制不同，有的限制每个域只能有20个Cookie，且每个域Cookie总大小限制在4095B，有的浏览器可能会多些。</p>

<h3>Cookie构成</h3>

<ul>
<li>名称：唯一确定cookie，名称是不区分大小写的</li>
<li>值：存储在cookie中的字符串的值，必须被URL编码</li>
<li>域：表示cookie对哪个域是有效的，所有向该有效域发送的请求都会加上这个cookie信息。如果没有设置，默认是设置cookie的域</li>
<li>路径：对于制定域中的那个路径，应该向服务器发送cookie</li>
<li>失效时间：表示cookie应该何时被删除。如果不设定，默认情况下，浏览器会话结束就会删除cookie（会话cookie）。如果设置了时间（大于当前时间），则浏览器关闭后cookie依然会保存在用户机器上（持久cookie）。这个值是GMT格式的日期。</li>
<li>安全标志</li>
</ul>


<h3>Javascript操作cookie</h3>

<p> <code>document.cookie</code>属性返回当前页面可用的（根据cookie的域、路径、失效时间和安全设置）所有cookie的字符串，一系列由分号分隔的名值对，如下：</p>

<pre><code>name1=value1;name2=value2;name3=value3
</code></pre>

<p>所有名字和值都是URL编码的，所以必须使用<code>decodeURIComponent()</code>解码。</p>

<p>设置值得时候，可以直接给<code>document.cookie</code>属性赋值，并不会覆盖cookie，除非设置的cookie名称已经存在。</p>

<p>由于cookie操作比较麻烦，并不直观，下面来看一个简化cookie操作的功能对象：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'>    <span class="kd">var</span> <span class="nx">CookieUtil</span><span class="o">=</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
</span><span class='line'>            <span class="kd">var</span> <span class="nx">cookieName</span> <span class="o">=</span> <span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;=&quot;</span><span class="p">,</span>
</span><span class='line'>                <span class="nx">cookieStart</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">indexof</span><span class="p">(</span><span class="nx">cookieName</span><span class="p">);</span>
</span><span class='line'>                <span class="nx">cookieValue</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="nx">cookieStart</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span><span class='line'>                <span class="kd">var</span> <span class="nx">cookieEnd</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">indexof</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">,</span><span class="nx">cookieStart</span><span class="p">);</span>
</span><span class='line'>                <span class="k">if</span><span class="p">(</span><span class="nx">cookieEnd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span><span class='line'>                    <span class="nx">cookieEnd</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="nx">cookieValue</span> <span class="o">=</span> <span class="nb">decodeURIComponent</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">cookieStart</span><span class="o">+</span><span class="nx">cookieName</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">cookieEnd</span><span class="p">));</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">return</span> <span class="nx">cookieValue</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">expires</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">domain</span><span class="p">,</span> <span class="nx">secure</span><span class="p">){</span>
</span><span class='line'>            <span class="kd">var</span> <span class="nx">cookieText</span> <span class="o">=</span> <span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;=&quot;</span><span class="o">+</span><span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="nx">expires</span> <span class="k">instanceof</span> <span class="nb">Date</span><span class="p">){</span>
</span><span class='line'>                <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s2">&quot;; expires=&quot;</span> <span class="o">+</span> <span class="nx">expires</span><span class="p">.</span><span class="nx">toGMTString</span><span class="p">();</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="nx">path</span><span class="p">){</span>
</span><span class='line'>                <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s2">&quot;; path=&quot;</span> <span class="o">+</span> <span class="nx">path</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="nx">domain</span><span class="p">){</span>
</span><span class='line'>                <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s2">&quot;; domain=&quot;</span> <span class="o">+</span> <span class="nx">domain</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="nx">secure</span><span class="p">){</span>
</span><span class='line'>                <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s2">&quot;; secure&quot;</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">=</span> <span class="nx">cookieText</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>





		
		<a href="/blog/2013/08/03/cookieyu-session/" class="more-link">Read on &rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-08-02T11:09:00+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/qian-duan/'>前端</a>


</div>
		
		
          | <a href="/blog/2013/08/02/ajaxxiang-guan-zong-jie/#comments">Comments</a>
         
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/08/02/ajaxxiang-guan-zong-jie/" itemprop="url">Ajax相关总结</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3>创建XMLHttpRequest对象</h3>

<p>创建XMLHttpRequest对象，跨浏览器兼容：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'>    <span class="kd">function</span> <span class="nx">createXHR</span><span class="p">(){</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 如果支持原生XHR对象</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">XMLHttpRequest</span> <span class="o">!=</span> <span class="s2">&quot;undefined&quot;</span><span class="p">){</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// 兼容IE6和之前版本</span>
</span><span class='line'>        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">ActiveXObject</span> <span class="o">!=</span> <span class="s2">&quot;undefined&quot;</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// arguments.callee.activeXString存放版本信息</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">.</span><span class="nx">activeXString</span> <span class="o">!=</span> <span class="s2">&quot;string&quot;</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>                <span class="c1">// 可能有3中不同版本的XHR对象</span>
</span><span class='line'>                <span class="kd">var</span> <span class="nx">versions</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;MSXML2.XMLHttp.6.0&quot;</span><span class="p">,</span> <span class="s2">&quot;MSXML2.XMLHttp.3.0&quot;</span><span class="p">,</span> <span class="s2">&quot;MSXML2.XMLHttp&quot;</span><span class="p">],</span>
</span><span class='line'>                    <span class="nx">i</span><span class="p">,</span><span class="nx">len</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>                <span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nx">len</span><span class="o">=</span><span class="nx">versions</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>                    <span class="c1">// 如果不能创建相应版本的XHR对象，会抛异常，继续检查下一个版本</span>
</span><span class='line'>                    <span class="k">try</span><span class="p">{</span>
</span><span class='line'>                        <span class="k">new</span> <span class="nx">ActiveXObject</span><span class="p">(</span><span class="nx">versions</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
</span><span class='line'>                        <span class="c1">// 如果可以创建该版本的XHR对象，则记录版本</span>
</span><span class='line'>                        <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">.</span><span class="nx">activeXString</span> <span class="o">=</span> <span class="nx">versions</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span><span class='line'>                        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>                    <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">ex</span><span class="p">){</span>
</span><span class='line'>                        <span class="c1">// 没有操作</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">return</span> <span class="k">new</span> <span class="nx">ActiveXObject</span><span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">.</span><span class="nx">activeXString</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;No XHR object available&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>响应处理</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'>    <span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="nx">createXHR</span><span class="p">()</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// 必须在调用open()之前指定onreadystatechange事件处理才能确保跨浏览器的兼容性</span>
</span><span class='line'>    <span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystartechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>        <span class="c1">// 请求/响应过程完成</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">==</span> <span class="mi">4</span><span class="p">){</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="nx">httpSuccess</span><span class="p">(</span><span class="nx">xhr</span><span class="p">)){</span>
</span><span class='line'>                <span class="c1">// 响应的处理</span>
</span><span class='line'>            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>                <span class="c1">// 请求/响应不成功</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">&quot;get&quot;</span><span class="p">,</span> <span class="s2">&quot;example.txt&quot;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">httpSuccess</span><span class="p">(</span><span class="nx">xhr</span><span class="p">){</span>
</span><span class='line'>        <span class="k">try</span><span class="p">{</span>
</span><span class='line'>            <span class="c1">// 如果得不到服务器状态，且我们正在请求本地文件，认为成功</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">!</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&amp;&amp;</span> <span class="nx">location</span><span class="p">.</span><span class="nx">protocol</span><span class="o">==</span><span class="s2">&quot;file:&quot;</span> <span class="o">||</span>
</span><span class='line'>
</span><span class='line'>                    <span class="c1">// 所有200到300间的状态码表示成功（包括200，不包括300）</span>
</span><span class='line'>                    <span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&lt;</span> <span class="mi">300</span><span class="p">)</span> <span class="o">||</span>
</span><span class='line'>
</span><span class='line'>                    <span class="c1">// 文档未修改也算成功</span>
</span><span class='line'>                    <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="mi">304</span> <span class="o">||</span>
</span><span class='line'>
</span><span class='line'>                    <span class="c1">// Safari 在文档未修改时返回空状态</span>
</span><span class='line'>                    <span class="nx">navigator</span><span class="p">.</span><span class="nx">userAgent</span><span class="p">.</span><span class="nx">indexof</span><span class="p">(</span><span class="s2">&quot;Safari&quot;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>                        <span class="k">typeof</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="s2">&quot;undefined&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">ex</span><span class="p">){}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>





		
		<a href="/blog/2013/08/02/ajaxxiang-guan-zong-jie/" class="more-link">Read on &rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-07-27T11:08:00+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/qian-duan/'>前端</a>


</div>
		
		
          | <a href="/blog/2013/07/27/httptou-xin-xi/#comments">Comments</a>
         
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/07/27/httptou-xin-xi/" itemprop="url">HTTP头信息</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>当我们在浏览器的地址栏中输入了URL之后发生了什么？</p>

<ol>
<li>浏览器分析我们输入的地址，解析所要使用的协议为HTTP协议</li>
<li>浏览器向DNS请求解析URL的IP地址</li>
<li>域名系统DNS解析出所请求的URL服务器的IP地址</li>
<li>浏览器与服务器建立TCP连接</li>
<li>浏览器发出HTTP请求</li>
<li>服务器通过HTTP响应把文件返回给浏览器</li>
<li>浏览器将文件进行解释，并将web页显示给用户</li>
</ol>


<h3>HTTP头信息</h3>

<p>每个HTTP请求和响应都分为消息头和消息体两部分，而头部信息是一定会有的。</p>

<p>默认情况下HTTP请求会发送下列的头信息：</p>

<ul>
<li>Accept：浏览器能够处理的内容类型&ndash;content-type</li>
<li>Accept-Charset：浏览器能显示的字符集</li>
<li>Accept-Encoding：浏览器能处理的压缩编码</li>
<li>Accept-Language：浏览器当前设置的语言</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cookie：当前页面设置的任何Cookie</li>
<li>Host：发出请求的页面所在的域</li>
<li>Referer：发出请求的页面的URL</li>
<li>User-Agent：浏览器的用户代理字符串（包括浏览器类型、操作系统信息等）</li>
</ul>


<p>看一个例子：</p>

<pre><code>GET /index.html HTTP/1.1
Accept:application/x-shockwave-flash
Accept-Language:zh-cn
Accept-Encoding:gzip
Cookie:name=value
User-Agent:Mozilla/4.0
Host:localhost:8080
Connection:Keep-Alive
</code></pre>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-07-15T11:04:00+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/shu-ju-ku/'>数据库</a>


</div>
		
		
          | <a href="/blog/2013/07/15/fan-shi/#comments">Comments</a>
         
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/07/15/fan-shi/" itemprop="url">范式</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>范式</h2>

<p>构造数据库必须遵循一定的规则。在关系数据库中，这种规则就是范式。范式是符合某一种级别的关系模式的集合。关系数据库中的关系必须满足一定的要求，即满足不同的范式。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、第四范式（4NF）、第五范式（5NF）和第六范式（6NF）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式（3NF）就行了。下面我们举例介绍第一范式（1NF）、第二范式（2NF）和第三范式（3NF）。</p>

<h3>第一范式（1NF）</h3>

<p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。所谓第一范式（1NF）是指</p>

<ul>
<li>数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。</li>
<li>在第一范式（1NF）中表的每一行只包含一个实例的信息。</li>
</ul>


<blockquote><p>简而言之，第一范式就是无重复的列。属性唯一</p></blockquote>

<h3>第二范式（2NF）</h3>

<blockquote><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。</p></blockquote>

<p>第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。</p>

<blockquote><p>简而言之，第二范式就是非主属性非部分依赖于主关键字。</p></blockquote>

<p>感觉很绕有没有？</p>

<p><strong>什么叫全部依赖，部分依赖？</strong>首先需要清楚一个概念，主关键字不是一个属性而是一组属性的集合，这个属性集合唯一的决定记录（实例）。现在再来看部分依赖，部分依赖就是主关键字这一组属性中的部分属性可以决定非主属性。</p>

<h3>第三范式（3NF）</h3>

<p>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</p>

<blockquote><p>简而言之，第三范式就是属性不依赖于其它非主属性。</p></blockquote>


		
		<a href="/blog/2013/07/15/fan-shi/" class="more-link">Read on &rarr;</a>
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
        <a href="2" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2015

    wibud


<!-- Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a> &#8211;>
</footer>
		</div>
	</div>
	






<!-- 
 -->


</body>
</html>
