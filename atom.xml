<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Winter Bud]]></title>
  <link href="http://wibud.github.io/atom.xml" rel="self"/>
  <link href="http://wibud.github.io/"/>
  <updated>2015-03-21T16:20:27+08:00</updated>
  <id>http://wibud.github.io/</id>
  <author>
    <name><![CDATA[wibud]]></name>
    <email><![CDATA[wi_bud@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[初识react]]></title>
    <link href="http://wibud.github.io/blog/2015/03/21/chu-shi-react/"/>
    <updated>2015-03-21T16:12:08+08:00</updated>
    <id>http://wibud.github.io/blog/2015/03/21/chu-shi-react</id>
    <content type="html"><![CDATA[<h2>是什么</h2>

<blockquote><p>React is a JavaScript library for creating user interfaces by Facebook and Instagram. Many people choose to think of React as the V in MVC.</p>

<p>We built React to solve one problem: building large applications with data that changes over time. To do this, React uses two main ideas.</p></blockquote>

<p>套用官网的一句话</p>

<blockquote><p>React可以被认为是MVC中得View层。它是用来构建数据不断变化的大型发杂应用的。</p></blockquote>

<p>所以不要拿React同Angular等框架作比较了，它只是View层的框架，没有什么可比性~~</p>

<p>在React中，贯穿始终的就是<code>组件</code>（组件化也是web发展的方向），React组件可以简单的认为是HTML和JavaScript的组合，通常的View层是使用一些模板工具生成，而React是通过组件的组合产出View，每个组件都可以独立或者配合使用（组件定义良好的话），其中React提供了一系列创建组件、渲染组件的方法，同时也对事件、状态等进行了封装。</p>

<p>为什么说React适合数据频繁变化的应用呢？</p>

<ul>
<li>数据变化时，只需更新组件的状态，剩下的操作React都帮你做了</li>
<li>React创造性的虚拟DOM和diff算法，使得其比传统的DOM更新更加高效，性能也更高</li>
</ul>


<p>这里不得不提一下<a href="http://facebook.github.io/jsx/">JSX</a>，它是和React配合使用的，当然不用也可以的（follow your heart~）。</p>

<blockquote><p>JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。React 可以用来做简单的 JSX 句法转换。</p></blockquote>

<p>简单说来，JSX就是可以将JavaScript 语法写成XML/HTML的那个样子，举个简单的例子：</p>

<pre><code>// 输入 (JSX):
var app = &lt;Nav color="blue" /&gt;;
// JSX 把类 XML 的语法转成原生 JavaScript，XML 元素、属性和子节点被转换成 React.createElement 的参数。
// 经JSX转化，输出 (JS):
var app = React.createElement(Nav, {color:"blue"});
</code></pre>

<h2>为什么</h2>

<p>我是否该使用React？别急，下面我们来详细看下。</p>

<h3>优点</h3>

<ul>
<li>只需要声明怎么展示，数据变化时，React自动帮你处理，不需要关心怎么更新DOM</li>
<li>React唯一需要做的就是构建组件，组件良好的封装性，更易于代码复用和关注分离</li>
<li>只需要查看组件的返回就能知道组件是如何渲染的，而不需要知道HTML和JS处理逻辑</li>
<li>方便维护和扩展</li>
</ul>


<h3>缺点</h3>

<ul>
<li>学习成本虽然不高，但是要理解和熟练掌握还是要花一定的时间，主要是官方文档错综发杂</li>
<li>React很年轻，社区也在发展中，相应的组件库并不丰富</li>
<li>React只是View层，实现一些复杂应用可能需要其他框架的支持</li>
</ul>


<h2>怎么用</h2>

<h3>如何显示</h3>

<p>先来看一个官网上的简单例子：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Hello React&lt;/title&gt;
        &lt;script src="http://fb.me/react-0.13.0.js"&gt;&lt;/script&gt;
        &lt;script src="http://fb.me/JSXTransformer-0.13.0.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="example"&gt;&lt;/div&gt;
        &lt;script type="text/jsx"&gt;

            var HelloWorld = React.createClass({

                render: function() {
                    return (
                        &lt;p&gt;
                            Hello, &lt;input type="text" placeholder="Your name here" /&gt;!
                            It is {this.props.date.toTimeString()}
                        &lt;/p&gt;
                    );
                }
            });

            setInterval(function() {
                React.render(
                    &lt;HelloWorld date={new Date()} /&gt;,
                    document.getElementById('example')
                );
            }, 500);

        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>在浏览器中运行这个例子，时间是每隔半秒钟变化一次。在输入框输入内容，你会发现 React 在用户界面中只改变了时间， 任何你在输入框输入的内容一直保留着，React知道哪些东西改变了，知道要更新哪些东西，并且帮你做好了。</p>

<p>其中用到了JSX，使用JSX的话，需要用<code>&lt;script type="text/jsx"&gt;</code>标签包裹JSX代码。</p>

<p>对这个组件的输入称为 props - &ldquo;properties&#8221;的缩写。得益于 JSX 语法，它们通过参数传递。不要去修改props的值， this.props 是只读的。</p>

<p>React 组件非常简单。你可以认为它们就是简单的函数，接受 props 和 state (后面会讨论) 作为参数，然后渲染出 HTML。正是应为它们是这么的简单，这使得它们非常容易理解。</p>

<h3>如何交互</h3>

<p>继续上官网里例子：</p>

<pre><code>var LikeButton = React.createClass({
    getInitialState: function() {
        return {liked: false};
    },
    handleClick: function(event) {
        this.setState({liked: !this.state.liked});
    },
    render: function() {
        var text = this.state.liked ? 'like' : 'haven\'t liked';
        return (
            &lt;p onClick={this.handleClick}&gt;
                You {text} this. Click to toggle.
            &lt;/p&gt;
        );
    }
});

React.render(
    &lt;LikeButton /&gt;,
    document.getElementById('example')
);
</code></pre>

<p>在浏览器中运行这个例子，每次点击按钮，我们的文案就换了。这里我们绑定了事件，同时用到了state。</p>

<p>这里的事件绑定与处理是经过React封装过得，当然封装是透明的，用起来和原生事件一样。</p>

<p>可以把React组件想象成一个状态机，状态（state）改变时，就会重新渲染变化，让组件呈现的界面同数据保持一致，实现起来十分简单，只需要调用<code>setState</code>方法，改变this.state，然后React会帮我们根据新的状态来重新渲染（完全不用开发者操心）</p>

<h4>使用<code>setState</code>的几点注意：</h4>

<ul>
<li><p><code>setState</code>不会立即更新state，也不会立即调用render进行重新渲染，看如下的例子</p>

<pre><code>  var i = 0;

  var Counter = React.createClass({

      getInitialState: function(){

          return {count: i};
      },
      handle: function(e){

          i++;
          this.setState({count: i});
          console.log(this.state.count, 'click');
      },
      render: function() {
          console.log(this.state.count, 'render');
          return (
              &lt;p onClick={this.handle}&gt;
                  i = {this.state.count}
              &lt;/p&gt;
          );
      }
  });

  React.render(
      &lt;Counter /&gt;,
      document.getElementById('example')
  );
</code></pre>

<p>  浏览器运行这个例子，页面渲染完，控制台会打印出<code>0 "render"</code>，点击一下<p>标签，打印出<code>0 "click"</code> <code>1 "render"</code>。自己想一下，不然可以得出结论。</p></li>
<li><p><code>setState</code>是将参数合并（merge）到this.state上，而不是替换</p></li>
</ul>


<h4>使用state的几点注意：</h4>

<ul>
<li>state只属于当前组件，不可传递</li>
<li>state应该只包含那些可能改变并触发用户界面更新的数据，其他的数据应该放到props中</li>
<li>常用的模式是创建多个只负责渲染数据的无状态（stateless）组件，在它们的上层创建一个有状态（stateful）组件并把它的状态通过 props 传给子级。这个有状态的组件封装了所有用户的交互逻辑，而这些无状态组件则负责声明式地渲染数据。</li>
<li>state中只是存放一些元数据，更具其计算出的数据，不要放到state中，把计算放到render()中。</li>
</ul>


<h3>如何组合组件</h3>

<p>React的很棒的特性之一就是他的组件的可组合性</p>

<pre><code>var User = React.createClass({
    render: function() {
        return (
            &lt;div&gt;
                &lt;UserName name={this.props.name} /&gt;
            &lt;/div&gt;
        );
    }
});

var UserName = React.createClass({
    render: function() {
        return (
            &lt;p&gt;
                {this.props.name}
            &lt;/p&gt;
        );
    }
});

React.render(
    &lt;User name="wibud" /&gt;,
    document.getElementById('example')
);
</code></pre>

<p>也可以很简单的实现批量添加子组件：</p>

<pre><code>var User = React.createClass({
    render: function() {
        return (
            &lt;div&gt;
                {this.props.names.map(function(name){

                    return &lt;UserName name={name} /&gt;
                })}
            &lt;/div&gt;
        );
    }
});

var UserName = React.createClass({
    render: function() {
        return (
            &lt;p&gt;
                {this.props.name}
            &lt;/p&gt;
        );
    }
});

React.render(
    &lt;User names={['wibud','wibud2','wibud3']} /&gt;,
    document.getElementById('example')
);
</code></pre>

<p>父组件和子组件可以通过props来传递数据，其中父组件可以通过this.props.children来获取子组件。</p>

<p>值得注意的是：子组件会根据他们被渲染的顺序来更新DOM，如下两次渲染过程：</p>

<pre><code>// 第一次渲染
&lt;List&gt;
    &lt;p&gt;item 1&lt;/p&gt;
    &lt;p&gt;item 2&lt;/p&gt;
&lt;/List&gt;
// 第二次渲染
&lt;List&gt;
    &lt;p&gt;item 2&lt;/p&gt;
&lt;/List&gt;
</code></pre>

<p>直观来看，只是删除了<code>&lt;p&gt;item 1&lt;/p&gt;</code>。事实上，React 先更新第一个子级的内容，然后删除最后一个组件。如果想要保证子组件渲染的正确顺序，即上述例子中删除<code>&lt;p&gt;item 1&lt;/p&gt;</code>，只需要给子组件加上<code>key</code>参数即可：</p>

<pre><code>render: function() {
    var results = this.props.results;
    return (
        &lt;ol&gt;
            {results.map(function(result) {
                return &lt;li key={result.id}&gt;{result.text}&lt;/li&gt;;
            })}
        &lt;/ol&gt;
    );
}
</code></pre>

<h3>如何复用组件</h3>

<h4>propTypes</h4>

<p>随着应用不断变大，保证组件被正确使用变得非常有用。为此我们引入 <code>propTypes    。</code>propTypes`是用来校验props数据的正确性的，如果数据类型不正确，会抛出异常。处于性能考虑，校验只在debug模式下有效。</p>

<p>具体可校验类型，参考<a href="http://facebook.github.io/react/docs/reusable-components.html">这里</a></p>

<p>使用起来也是超级的简单：</p>

<pre><code>var MyComponent = React.createClass({
    propTypes: {
        children: React.PropTypes.element.isRequired
    },

    render: function() {
        return (
            &lt;div&gt;
                {this.props.children} // 有且仅有一个元素，否则会抛异常。
            &lt;/div&gt;
        );
    }
});
</code></pre>

<h4>Mixins</h4>

<p>组件是 React 里复用代码最佳方式，但是有时一些复杂的组件间也需要共用一些功能。React 使用 mixins 来解决这类问题。</p>

<p>如下例子，我们实现了通用的setInterval的创建和销毁</p>

<pre><code>var SetIntervalMixin = {
    // 组件Render前调用
    componentWillMount: function() {
        this.intervals = [];
    },
    setInterval: function() {
        this.intervals.push(setInterval.apply(null, arguments));
    },
    // 组件销毁时调用
    componentWillUnmount: function() {
        this.intervals.map(clearInterval);
    }
};

var TickTock = React.createClass({
    // 引用 mixin
    mixins: [SetIntervalMixin],

    getInitialState: function() {
        return {seconds: 0};
    },
    // 组件render完后调用
    componentDidMount: function() {
        this.setInterval(this.tick, 1000); // 调用 mixin 的方法
    },
    tick: function() {
        this.setState({seconds: this.state.seconds + 1});
    },
    render: function() {
        return (
            &lt;p&gt;
                React has been running for {this.state.seconds} seconds.
            &lt;/p&gt;
        );
    }
});

React.render(
    &lt;TickTock /&gt;,
    document.getElementById('example')
);
</code></pre>

<p>mixin相当于把通过mixin定义的方法属性赋到组件对象中，如果有多个mixin时，并用有多个 mixin 定义了同样的生命周期方法，即componentWillUnmount等方法（如：多个 mixin 都需要在组件销毁时做资源清理操作），所有这些生命周期方法都保证会被执行到。方法执行顺序是：首先按 mixin 引入顺序执行 mixin 里方法，最后执行组件内定义的方法。</p>

<h3>组件生命周期</h3>

<h4>组件初始化</h4>

<ul>
<li>1、getDefaultProps()</li>
<li>2、getInitialState()</li>
<li>3、componentWillMount()</li>
<li>4、render()</li>
<li>5、componentDidMount()</li>
</ul>


<h4>组件销毁</h4>

<ul>
<li>1、componentWillUnmount()</li>
</ul>


<h4>调用setState()后的更新流程</h4>

<ul>
<li>1、shouldComponentUpdate()</li>
<li>2、componentWillUpdate()</li>
<li>3、render()</li>
<li>4、componentDidUpdate()</li>
</ul>


<h3>class和style</h3>

<p>这里是针对JSX的</p>

<ul>
<li>class处理</li>
</ul>


<p>给节点设置样式时，需要用<code>className</code>，可以使用<code>React.addons.classSet</code>来设置多个class：</p>

<pre><code>render: function(){
    var classes = React.addons.classSet({
        'classOne': true,   // 需要
        'classTwo': false // 不需要
    });

    return &lt;div className={classes}&gt;&lt;/div&gt;
}
</code></pre>

<p>渲染的结果里，div元素会只有classOne这一个样式类。</p>

<ul>
<li>内联style</li>
</ul>


<p>实例如下：</p>

<pre><code>render: function(){
    var styles = {
        color: 'red',
        height: 10
    };

    return &lt;div style={styles}&gt;&lt;/div&gt;
}
</code></pre>

<h3>常用API</h3>

<ul>
<li><p>render()</p>

<ul>
<li>渲染组件</li>
<li>render方法要保持简单</li>
</ul>
</li>
<li><p>componentWillMount()</p>

<ul>
<li>render前调用，只触发一次</li>
<li>可做一些初始化的工作</li>
</ul>
</li>
<li><p>componentWillUnmount()</p>

<ul>
<li>组件销毁前调用</li>
<li>做一些清理工作</li>
</ul>
</li>
<li><p>getInitialState()</p>

<ul>
<li>设置初始的state值</li>
</ul>
</li>
<li><p>getDefaultProps()</p>

<ul>
<li>设置默认的prop值</li>
<li>用户未设置时，会去默认值</li>
</ul>
</li>
<li>setState()

<ul>
<li>更新state</li>
</ul>
</li>
</ul>


<p>更多API参见<a href="http://facebook.github.io/react/">官网</a></p>

<h3>Virtual DOM 和 Diff算法</h3>

<p>有兴趣看下面的资料汇总</p>

<h1>资料汇总</h1>

<ul>
<li><a href="http://facebook.github.io/react/">官网</a></li>
<li><a href="https://github.com/facebook/react/tree/master/docs/docs">文档教程(有一部分翻译成了中文)</a></li>
<li><a href="https://github.com/facebook/react/wiki/Complementary-Tools">Complementary Tools工具和组件</a></li>
<li>react virtual dom

<ul>
<li><a href="http://fluentconf.com/fluent2014/public/schedule/detail/32395">The Secrets of React&rsquo;s Virtual DOM</a></li>
<li><a href="http://stackoverflow.com/questions/21109361/why-is-reacts-concept-of-virtual-dom-said-to-be-more-performant-than-dirty-mode">Why is React&rsquo;s concept of Virtual DOM said to be more performant than dirty model checking?</a></li>
</ul>
</li>
<li><a href="http://calendar.perfplanet.com/2013/diff/">react diff algorithm</a></li>
<li><a href="https://github.com/flipboard/react-canvas">react-canvas</a>

<ul>
<li><a href="http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html">相关阅读</a></li>
</ul>
</li>
<li><a href="https://egghead.io/series/react-flux-architecture">React: Flux Architecture</a></li>
<li><a href="https://github.com/mhart/react-server-example">example of how to do server-side rendering with the React library</a></li>
<li><a href="http://weibo.com/reactchina">React 中文微博</a></li>
<li><a href="http://react-china.org/">React 中文社区</a></li>
<li><a href="https://www.codementor.io/reactjs/tutorial/react-vs-angularjs">react-vs-angularjs</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dive into requestAnimationFrame]]></title>
    <link href="http://wibud.github.io/blog/2014/12/01/dive-into-requestanimationframe/"/>
    <updated>2014-12-01T00:14:36+08:00</updated>
    <id>http://wibud.github.io/blog/2014/12/01/dive-into-requestanimationframe</id>
    <content type="html"><![CDATA[<h2>介绍</h2>

<p>requestAnimationFrame(以下简称raf)方法，字面意思上看是：请求动画帧；较官方的解释是：通知在系统准备好绘制动画帧时调用该帧，从而为创建动画网页提供了一种更平滑更高效的方法；那通俗一点就是：告诉浏览器说 “我这里有一帧（一些操作），需要你帮我绘制（执行）一下”，“ok，没问题，我挑个合适的时机给你绘制这一帧（执行这些操作）”</p>

<p><img src="http://wibud.github.io/images/private/raf-1.jpg" alt="" /></p>

<ul>
<li><p>一、浏览器的绘制（执行）时机是嘛时候</p>

<p>  首先，我们需要了解的是，页面的绘制由CPU或者GPU进行的，但是其绘制频率受限于我们的显示器的刷新频率，一般显示器的刷新频率是60HZ，所以对应于绘制频率最高就是60fps（frame per second）。于是60fps也成了检验性能的一个重要的指标，be closer be better，通常来说，在30fps到60fps之间都是可以接受的。</p>

<p>  60fps意味着我们执行每一帧的时间只有大约16.7ms（1000/60），这也是常见的使用setTimeout和setInterval实现动画时所设置的间隔时间。那对于raf来说呢，我们将绘制（执行）时机交给了浏览器自己进行判断，浏览器在合适的时机来绘制（执行）我们提供给浏览器的帧（操作）。浏览器如何决定这个合适时机的呢？（均基于chrome环境）</p>

<blockquote><p>raf最大的调用频率不会超过60fps</p></blockquote>

<p>  主观上来说，60fps已经达到了很好效果，没必要用到更快的更新频率了。貌似这一点也是chromium对于raf的设计原则之一，为了印证这一结论，特地去扒了扒chromium中raf的执行流程</p>

<p>  <img src="http://wibud.github.io/images/private/chromium-request-anim-frame.png" alt="" /></p>

<p>  从流程图可以看到</p>

<pre><code>  if (animation update pending and &gt;= 16ms since last update)
      post task to anticipate next frame
  else
      post task to retry in (next_frame - now)ms
</code></pre>

<p>  如果有等待的animation更新且距离上一次更新超过16ms，则会post task，来准备下一帧，也就是说</p>

<blockquote><p>针对chrome而言，无论屏幕的刷新频率是多少，raf回调函数的执行频率不会超过60次/秒</p></blockquote>

<p>  找了大量的资料也没有找到raf回调的执行时机是如何计算的，唯一的途径只有看源码了，不过源码是C++，出了大学课堂就再没用过，全忘干净了。。。，大体看了看，貌似原理是：如果上一次raf的回调执行时间过长，那么触发下一次raf回调的时间就会缩短，反之亦然，目的是保证动画不丢帧。（如有错误，请轻拍~~）</p>

<p>  其实，raf不需要关心屏幕什么时候刷新，也并不是在屏幕刷新的时候进行绘制，而是保证在屏幕刷新间隔内不会有两个帧的绘制而导致前一个帧丢失。</p></li>
</ul>


<!-- more -->


<ul>
<li><p>二、raf如何使动画更平滑更高效</p>

<p>  为何说raf能使动画更平滑更高效呢？</p>

<blockquote><p>raf并非升帧，并非加快执行速度，而是适当时候降帧，防止并解决丢帧问题</p></blockquote>

<p>  如此，虽然降帧了，比如降到30fps，但是因为视觉暂留的原理，我们依然会觉得动画是连贯的，而不会因为丢帧二导致动画断续、卡顿显示。从而使动画更加平滑。</p>

<p>  之所以说raf使动画更平滑和高效，是相对于原来使用setTimeout或setInterval的实现来说的，下节会详细讨论。</p></li>
</ul>


<p>在这里不谈requestAnimationFrame(以下简称rAF)用法，具体请参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame">MDN:Window.requestAnimationFrame()</a>。</p>

<h2>setTimeout(setInterval) VS requestAnimationFrame</h2>

<p>以下将setTimeout和setInterval统称为Timer。</p>

<p><img src="http://wibud.github.io/images/private/raf-2.png" alt="" /></p>

<p>上面第一行表示大多数监视器上显示的 16.7ms 显示频率，而下面一行表示的 10ms的Timer。每个第三个图形都无法绘制（由红色箭头指示），因为在显示器刷新间隔之前发生了其他绘制请求，也就是说第三个图形还没绘制，第四个图形的绘制请求就来了，导致下一次绘制，只会绘制第四个图形。这种过度绘制的情况会导致动画断续显示，因为所有第三帧都会丢失。</p>

<p>那我们把Timer的时间间隔设置为16.7ms呢？</p>

<ul>
<li><p>首先，Timer时间间隔是依靠浏览器的时钟来计算的，时钟的精确度是取决于时钟的更新频率的，比如，在IE8-中，时钟的更新频率是15.6ms，也就是说如果你设置Timer的时间间隔是16.7ms，那也要等两个15.6ms才会执行Timer的回调。目前chrome和IE9+的更新频率是4ms，如果是笔记本，在使用电池的情况下，时钟的更频率会变的更低。</p></li>
<li><p>其次，就算Timer时间间隔不依赖浏览器时钟更新或者说能和时钟更新保持一致，但是我们知道，Timer的实现机制是在设置的时间间隔后往任务队列里push执行回调函数的任务，如果在Timer的回调函数执行任务之前存在大量其他任务的话，任务队列是需要执行完这些任务，才会执行Timer的任务，就导致实际执行回调的时间要大于我们设置的时间间隔。</p></li>
<li><p>最后，就算没有之上的两个问题，我们的Timer可以在时间间隔上准确执行，依然会有丢帧的问题，比如我们将Timer时间间隔设置为16.7ms，屏幕的刷新频率是60Hz（时间间隔16.666&hellip;7），Timer更新频率同屏幕刷新频率是有误差的，随着动画运行时间的推移，误差会不断累加，大约在500s后，会发生丢帧。</p></li>
</ul>


<p>其他问题：</p>

<p>Timer可能会导致动画过度绘制，浪费 CPU 周期以及消耗额外的电能等问题。而且，即使看不到网站，特别是当网站使用背景选项卡中的页面或浏览器已最小化时，动画都会频繁出现。参见这篇<a href="http://segmentfault.com/blog/humphry/1190000000386368">翻译文章</a>，标签页闲置时，时间间隔如下：</p>

<table>
<thead>
<tr>
<th>                  </th>
<th style="text-align:center;"> setInterval </th>
<th style="text-align:right;"> requestAnimationFrame </th>
</tr>
</thead>
<tbody>
<tr>
<td> IE10+ </td>
<td style="text-align:center;"> 无影响(时间间隔不变) </td>
<td style="text-align:right;"> 暂停 </td>
</tr>
<tr>
<td> IE9- </td>
<td style="text-align:center;"> 无影响 </td>
<td style="text-align:right;"> 不支持 </td>
</tr>
<tr>
<td> Safari </td>
<td style="text-align:center;"> >= 1s </td>
<td style="text-align:right;"> 暂停 </td>
</tr>
<tr>
<td> Firefox </td>
<td style="text-align:center;"> >= 1s </td>
<td style="text-align:right;"> 1s - 3s </td>
</tr>
<tr>
<td> Chrome </td>
<td style="text-align:center;"> >= 1s </td>
<td style="text-align:right;"> 暂停 </td>
</tr>
<tr>
<td> Opera </td>
<td style="text-align:center;"> >= 1s </td>
<td style="text-align:right;"> 暂停 </td>
</tr>
</tbody>
</table>


<p>其实，在现代浏览器中，对于Timer也是做了不少优化的，单从fps角度上来说，Timer和raf相差不大（参考<a href="http://segmentfault.com/blog/humphry/1190000000400068">这篇测试文章</a>），raf比之于Timer，最大的优势是解决了丢帧问题~~</p>

<p>对了，从setTimeout切换至raf非常容易，他们都是单一回调，以下是一个很完善的兼容的方法，可以放心大胆的用了，妈妈再也不用担心我的兼容问题了~~</p>

<pre><code>(function() {
    var lastTime = 0;
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for(var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
            window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
        }

        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = function(callback, element) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16.7 - (currTime - lastTime));
                var id = window.setTimeout(function() {
                    callback(currTime + timeToCall);
                }, timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };
        }
        if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = function(id) {
                clearTimeout(id);
            };
        }
}());
</code></pre>

<h2>CSS Animation VS requestAnimationFrame</h2>

<h3>一、性能</h3>

<p>一般我们会认为CSS动画的性能肯定会比js帧动画性能要好，因为CSS动画可以被硬件加速，通过GPU可以提升动画性能。真的是这样吗？</p>

<p>其实硬件（GPU）加速的应该是层（GraphicLayer）的合成，而CSS动画可以让应用动画的层成为一个独立的层（GraphicLayer），成为独立的层简单来说有如下好处：</p>

<ul>
<li>每个GraphicsLayer都有一个GraphicsContext，GraphicsContext会输出该层的位图，交由GPU合成，比CPU要快</li>
<li>当需要repaint时，只需要repaint自己，不会影响到其他的GraphicsLayer。repaint完之后，只需要通过GPU同其他层合并下（composite layers）</li>
<li>对于CSS transform等，不需要repaint</li>
</ul>


<p>而元素（准确的说应该是RenderLayer）想要拥有独立的GraphicLayer，满足如下条件即可：</p>

<ul>
<li>Layer has 3D or perspective transform CSS properties</li>
<li>Layer is used by video element using accelerated video decoding</li>
<li>Layer is used by a canvas element with a 3D context or accelerated 2D context</li>
<li>Layer is used for a composited plugin</li>
<li>Layer uses a CSS animation for its opacity or uses an animated webkit transform</li>
<li>Layer uses accelerated CSS filters</li>
<li>Layer has a descendant that is a compositing layer</li>
<li>Layer has a sibling with a lower z-index which has a compositing layer (in other words the layer overlaps a composited layer and should be rendered on top of it)（chrome中做了优化，方式该情况下出现的层过多）</li>
</ul>


<p>详细可戳这里<a href="http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome">GPU Accelerated Compositing in Chrome</a></p>

<p>也就是说即使是用js帧动画，我们也可以通过让动画元素拥有独立的GraphicLayer，来使用GPU合成加速。这里需要注意的是，独立的GraphicLayer会占用内存（显存），尤其是在手机上，大部分手机的显存和内存是共享的，GraphicsLayer过多导致内存占用过多的话，会使手机变卡。</p>

<p>所以说在性能方便CSS动画和js帧动画直接差别不大，而且某些CSS动画可能也会给GPU带来过大的压力，导致动画性能并不高。Adobe的<a href="http://blogs.adobe.com/webplatform/2014/03/18/css-animations-and-transitions-performance/">这篇文章</a>中，对两类动画做了分析，本别是transition: height和 transition: transform，其中用CSS动画改变元素的高度，动画性能并不高，有兴趣去看一下这篇文章，这里就不赘述了。（文章中，paint操作现在应该是在合成线程composite thread中进行的，而不是在主线程中）</p>

<p>就目前来说，对于CSS transform、CSS opacity、CSS filter，使用CSS动画会比js帧动画好，因为针对这些属性的CSS动画并不阻塞执行js的主线程，而使用js帧动画势必会占用主线程。</p>

<h3>二、控制性</h3>

<p>这个就不需多说了，相信大家都知道，肯定是js帧动画胜出了。</p>

<h3>三、浏览器支持情况</h3>

<p>raf的支持情况可以去<a href="http://caniuse.com/">caniuse</a>去查下，raf支持情况没有CSS动画好，在android4.4+才支持raf，而在android4.4下，使用js帧动画只能用setTimeout或者setInterval了，效果估计就没有CSS动画那么给力了。</p>

<h2>参考文档</h2>

<ul>
<li><a href="http://www.chromium.org/developers/design-documents/rendering-architecture-diagrams">Rendering Architecture Diagrams</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame">MDN:Window.requestAnimationFrame()</a></li>
<li><a href="http://davidwalsh.name/css-js-animation">CSS vs. JS Animation: Which is Faster?</a></li>
<li><a href="http://greensock.com/transitions/">CSS3 Transitions vs GSAP: Cage Match</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/speed/animations/?redirect_from_locale=zh">Leaner, Meaner, Faster Animations with requestAnimationFrame</a></li>
<li><a href="http://blogs.adobe.com/webplatform/2014/03/18/css-animations-and-transitions-performance/">CSS animations and
transitions performance:
looking inside the browser</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GPU Accelerated Compositing in Chrome（GPU加速合成）]]></title>
    <link href="http://wibud.github.io/blog/2014/11/03/yi-gpu-accelerated-compositing-in-chrome(gpuhe-cheng-jia-su-)/"/>
    <updated>2014-11-03T00:10:52+08:00</updated>
    <id>http://wibud.github.io/blog/2014/11/03/yi-gpu-accelerated-compositing-in-chrome(gpuhe-cheng-jia-su-)</id>
    <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome">http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome</a></p>

<p>作者：Tom Wiltzius, Vangelis Kokkevis &amp; the Chrome Graphics team</p>

<p>其中包含个人理解，如有出入，请轻拍！</p></blockquote>

<p>先来简单的总结下！</p>

<p>硬件（GPU）加速加速的是啥？是层的合成（layer composite），所以有些说使用translate3D打开硬件加速的说法是不恰当的，GPU加速是一直在的（在有GPU且设备的图形驱动可用的情况下），在chrome中，使用translate3D其实是使该元素拥有独立的GraphicsLayer，那拥有独立的GraphicsLayer有啥好处呢？简单来说有如下几点：</p>

<ul>
<li>每个GraphicsLayer都有一个GraphicsContext，GraphicsContext会输出该层的位图，交由GPU合成，比CPU要快</li>
<li>当需要repaint时，只需要repaint自己，不会影响到其他的GraphicsLayer。repaint完之后，只需要通过GPU同其他层合并下（composite layers）</li>
<li>对于CSS动画，不需要repaint</li>
</ul>


<p>下面简单介绍下chrome的渲染原理，详细了解可看下面译文或者直接读原文：</p>

<p>在chrome中为render服务的有4种树形结构，我们熟知的DOM树是其中之一，其他的三个分别是：</p>

<ul>
<li><p>RenderObject Tree</p>

<p>  由RenderObject构成，RenderObject同DOM树中得Node节点一一对应，RenderObject知道如何去paint（paint != draw）其对应的Node。</p></li>
<li><p>RenderLayers Tree</p>

<p>  由RenderLayer构成，RenderLayer同RenderObject是一对多的关系，满足如下条件的RenderObject拥有新的RenderLayer，而其他的RenderObject就和它的第一个拥有独立RenderLayer的父元素公用一个RenderLayer。</p>

<ul>
<li>页面的根节点的RenderObject</li>
<li>有明确的CSS定位属性（relative，absolute或者transform）</li>
<li>是透明的</li>
<li>有CSS overflow、CSS alpha遮罩（alpha mash）或者CSS reflection</li>
<li>有CSS 滤镜（fliter）</li>
<li>3D环境或者2D加速环境的canvas元素对应的RenderObject</li>
<li>video元素对应的RenderObject</li>
</ul>
</li>
<li><p>GraphicsLayers Tree</p>

<p>  由GraphicsLayer构成，GraphicsLayer同RenderLayer的关系和RenderLayer同RenderObject的关系是一样的。满足如下条件的RenderLayer会拥有新的GraphicsLayer。</p>

<ul>
<li>有3D或者perspective transform的CSS属性的层</li>
<li>使用加速视频解码的video元素的层</li>
<li>3D或者加速2D环境下的canvas元素的层</li>
<li>插件，比如flash（Layer is used for a composited plugin）</li>
<li>对opacity和transform应用了CSS动画的层</li>
<li>使用了加速CSS滤镜（filters）的层</li>
<li>有合成层后代的层</li>
<li>同合成层重叠，且在该合成层上面（z-index）渲染的层</li>
</ul>


<p>  每个GraphicsLayer都有一个GraphicsContext，GraphicsContext会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到GPU中，最后由GPU将多个位图进行合成，然后draw到屏幕上。</p>

<p>  需要注意的是</p>

<blockquote><p>GraphicsLayer是消耗内存资源的</p></blockquote>

<p>  所以说，对于像translate3D这样的hack不要过度使用，尤其是在手机上，大部分手机的显存和内存是共享的，GraphicsLayer过多导致内存占用过多的话，会使手机变卡的。</p></li>
</ul>


<p>在chrome为渲染服务的有两个进程：Render进程和GPU进程。GPU进程负责Render进程和GPU之间的命令的传递，Render进程包括主线程和合成线程，在chrome中，paint和composite放在了合成线程中。</p>

<!-- more -->


<p>译文如下：</p>

<hr />

<h3>摘要</h3>

<p>本文讲述了chrome中硬件加速合成（compositing[1]）的实现</p>

<h3>简介：为什么使用硬件进行合成（compositing）</h3>

<p>传统方式下，浏览器依赖于CPU来渲染页面内容。而随着GPU硬件能力的不断发展（包括一些超小型设备的硬件能力也有很大提升），人们开始试图使用GPU的硬件能力来获得更好的性能和更少的电量消耗。使用GPU来渲染合成页面内容可以获得明显的速度的提升。</p>

<p>硬件合成有以下几个优点：</p>

<ul>
<li><p>GPU在合成页面layer上的效率要比CPU高很多，尤其是涉及大量像素的drawing[2]和compositing操作。当然，GPU设计出来本来就是做这些工作的。</p></li>
<li><p>Expensive readbacks aren&rsquo;t necessary for content already on the GPU (such as accelerated video, Canvas2D, or WebGL).</p></li>
<li><p>Parallelism between the CPU and GPU, which can operate at the same time to create an efficient graphics pipeline.</p></li>
</ul>


<h2>Part 1：Blink Rending 基础</h2>

<p>Blink Rending 引擎（由Google和Opera Software开发的浏览器排版引擎）的源码十分繁多和复杂。为更好理解在chrome中GPU加速是如何工作的，我们首先需要了解Blink引擎是如何渲染页面的。</p>

<h3>Nodes和DOM树</h3>

<p>在Blink引擎中，页面内容是存储为由Node对象组成的树状结构，也就是DOM树。每一个HTML element元素都有一个Node对象与之对应，DOM树的根节点永远都是Document Node。</p>

<h3>从Nodes到RenderObjects</h3>

<p>DOM树中得每个node节点都有一个对应的RenderObject。RenderObject存储在与DOM树相对应的树形结构中——Render Tree。RenderObject知道如何在屏幕上paint[3] Node内容，当然为实现这一操作，RenderObject会调用GraphicsContext来执行必要的draw[2]操作。其中，GraphicsContext就是负责将像素写入位图（bitmap）[4]中，这些位图最终会展示在屏幕上。</p>

<p>在老的实现方式下（不使用GPU），大部分GraphicsContext调用其实是去调用一个SkCanvas或者SkPlatformCanvas（Skia Graphics Library2D图形处理库的类）等等，将其paint进一个software bitmap中（参考<a href="http://www.chromium.org/developers/design-documents/graphics-and-skia">这篇文章</a>了解更多细节）。但是，现在painting不再放在主线程（main thread）（本文之后会讲到），这些命令现在会记录到一个SkPicture中。SkPicture是一个序列化的数据结构，它可以捕获调用命令并在之后重发这些命令，类似一个<a href="http://en.wikipedia.org/wiki/Display_list">display list</a></p>

<h3>从RenderObjects到RenderLayers</h3>

<p>每一个RenderObject都直接或间接（通过其父对象）的同一个RenderLayer相关联。</p>

<p>一般来说，拥有相同的坐标空间（比如：受相同CSS transform影响的）的RenderObjects，属于同一个RenderLayer。RenderLayer的作用就是保证页面元素以正确的顺序合成（composited），这样才能正确的展示元素的重叠以及半透明元素等等。会有一些情形，为一些特殊的RenderObjects创建一个新的RenderLayer。以下是常见的一定会新建RenderLayer的RenderObject：</p>

<ul>
<li>页面的根节点的RenderObject</li>
<li>有明确的CSS定位属性（relative，absolute或者transform）</li>
<li>是透明的</li>
<li>有CSS overflow、CSS alpha遮罩（alpha mash）或者CSS reflection</li>
<li>有CSS 滤镜（fliter）</li>
<li>3D环境或者2D加速环境的canvas元素对应的RenderObject</li>
<li>video元素对应的RenderObject</li>
</ul>


<p>值得注意的是，RenderObject同RenderLayer并不是一对一的。对于上述特殊的RenderObjects，它对应于为它所创建的新的RenderLayer，而其他的RenderObjects，对应于其第一个拥有RenderLayer的父RenderObject</p>

<p>RenderLayer也是一个树状的结构。根节点就是页面根元素所对应的RenderLayer，视觉上，每一个layer节点的后代都包含在父layer中。每一个RenderLayer的子layer保存在两个升序排列的列表中，分别是negZOrderList（负z-index的layers，即当前layer之下的layer）和posZOrderList（正z-index的layers，即当前layer之上的layer）</p>

<h3>从RenderLayers到GraphicsLayers</h3>

<p>为利用合成器（compositor），一些（不是全部）RenderLayers有独立的backing surface（有独立backing surface的layer被认为是合成层（compositing layers））。如果RenderLayer是一个合成层，那么它有属于它自己的单独的GraphicsLayer，否则它和它的第一个拥有GraphicsLayer的父layer共用一个GraphicsLayer。如同RenderObject同Renderlayer的关系一样。</p>

<p>每一个GraphicsLayer都有一个GraphicsContext，其对应的RenderLayer会paint进GraphicsContext中。合成器（compositor）最终会负责，将由GraphicsContext输出的位图（bitmap[4]）合并成最终屏幕显示的图案。</p>

<p>虽然，在理论上，每一个独立的RenderLayer都可以paint进一个独立的backing surface中（拥有自己独立的backing surface，成为独立的合成层），但是，实际上，这样做十分消耗显存。在当前的Blink引擎的实现中，只有在如下的场景中，RenderLayer会是独立的合成层：</p>

<ul>
<li>有3D或者perspective transform的CSS属性的层</li>
<li>使用加速视频解码的video元素的层</li>
<li>3D或者加速2D环境下的canvas元素的层</li>
<li>插件，比如flash（Layer is used for a composited plugin）</li>
<li>对opacity和transform应用了CSS动画的层</li>
<li>使用了加速CSS滤镜（filters）的层</li>
<li>有合成层后代的层</li>
<li>同合成层重叠，且在该合成层上面（z-index）渲染的层</li>
</ul>


<h3>层压缩（Layer Squashing）</h3>

<p>所有的规则都会有漏洞。正如上面提到的，GraphicsLayers会消耗内存和其他资源（比如一些饱受争议的操作，随着GraphicsLayer树的大小增长，会使CPU执行时间越来越长）。当一些RenderLayer同一个有着独立backing surface的RenderLayer重叠时，就会产生大量的额外的层，十分消耗资源。</p>

<p>我们把产生合成层的自身原因（比如有3D变换的层）称之为直接原因（direct compositing reasons）。为了防止上述所说的“层爆炸”，当很多element覆盖在因直接原因产生的层之上时，Blink引擎，会将这些element的RenderLayers覆盖在“direct compositing reason”的RenderLayer上，同时将他们压缩（squash）成单一的一个backing store。这就防止了由覆盖引起的层爆炸。更多细节请看<a href="https://docs.google.com/presentation/d/1WOhbWLkhMyo4vZUaHq-FO-mt0B2sejXw-lMwohD5iUo/edit#slide=id.g2a8a2080a_088">这里</a>和<a href="https://docs.google.com/a/chromium.org/presentation/d/1dDE5u76ZBIKmsqkWi2apx3BqV8HOcNf4xxBdyNywZR8/edit#slide=id.p">这里</a></p>

<h3>从GraphicsLayers到WebLayers再到CC Layers</h3>

<p>chrome在 src/webkit/renderer/compositor_bindings中实现了Web*Layer的接口。通过Web*Layer和cc layer（chrome compositor layer）实现GraphicsLayers。</p>

<h3>The compositing Forest</h3>

<p>总的来说，为rendering服务的有如下四种树形结构：</p>

<ul>
<li>DOM Tree，基本的模型</li>
<li>RenderObject Tree，同DOM树的可见节点是一一对应的。RenderObject知道如何去paint其相对应的DOM节点</li>
<li>RenderLayer Tree，由RenderLayers组成，这些RenderLayer对应于RenderObject树的RenderObject。这种对应关系是一对多的。</li>
<li>GraphicsLayer Tree，由GraphicsLayers组成，这些GraphicsLayer对应于RenderLayer树的RenderLayer。这种对应关系是一对多的。</li>
</ul>


<p>如下图所示：</p>

<p><img src="http://wibud.github.io/images/private/The-Compositing-Forest.png" alt="" /></p>

<p>之后文章中所说的层（layer）都代指cc layer（chrome compositor layer：GraphicsLayer在chrome中得实现）。合成器（Compositor）操作的是cc layer。</p>

<h2>Part 2：The Compositor（合成器）</h2>

<p>chrome合成器（Compositor）是一个软件库，用来管理GraphicsLayer树以及协调帧（frame）生命周期。代码在src/cc下。</p>

<h3>Compositor介绍</h3>

<p>回想一下，rendering有两个阶段：先是paint然后composite。合成器会在每个合成层（per-compositing-layer）的基础上执行一些额外的工作。比如，在合成层的位图合成前，合成器会负责对这些合成层的位图执行一些必要的transform（比如层的CSS tranform属性指定的变换）。另外，因为层的painting和compositing解耦了，所以一个invalidating[6]（需要repainting的）层只会重绘（repainting）自己的内容，然后所有层重新进行合成（recopositing）。</p>

<p>每次浏览器需要创建一个新的帧，合成器就需要draw。这里drawing是指合成器将层合成为最终的屏幕画面。</p>

<h3>GPU是干啥的？</h3>

<p>GPU是如何发挥作用的呢？合成器会使用GPU来执行它的drawing的步骤。这和老的软件渲染模型有显著的区别，在老的模型中，Render进程将页面内容的位图（bitmap）通过IPC（进程间通信）和共享内存的方式来传给浏览器进程去呈现。</p>

<p>在硬件加速体系结构中，合成由GPU负责，GPU通过调用平台特定的3D API（windows是D3D，其他是GL）来实现。合成器本质上也是使用GPU将页面的矩形区域（比如，相对于视口且根据layer树的优先级定位的所有合成层）draw成一个位图，也就是最终的屏幕图像。</p>

<h2>GPU进程</h2>

<p>首先我们需要了解Render进程如何传递命令给GPU的。在chrome多进程模型中，有一个专门的进程负责这个任务：GPU进程。GPU进程的存在主要是因为安全原因。需要注意的是，android是个例外，Chrom会使用内置的GPU实现作为浏览器主进程的一个线程来运行。当然android上的GPU线程和其他平台的GPU进程的行为是一致的。</p>

<p>受沙盒的限制，Render进程无法直接调用操作系统（GL/D3D）提供的3D API。因此，我们使用一个独立的进程访问，也就是GPU进程。而GPU进程也是专门被设计用来访问在沙箱或者更严格的<a href="http://www.chromium.org/nativeclient">Native Client</a>中的系统3D API的。GPU进程的工作模式是一种client-server模式，原理如下：</p>

<ul>
<li>客户端（运行在Render进程或者<a href="http://zh.wikipedia.org/wiki/Google_Native_Client">NaCl</a>模块中的代码），会系列化调用命令，并把他们放到环形缓冲区（命令缓冲区command buffer）中，存储在由客户端和服务端共享的内存中。</li>
<li>服务端（在允许访问平台3D API的低限制级别的沙盒中运行的GPU进程），会从共享内存中拾取序列化的命令，解析他们，并执行相应的图形调用。</li>
</ul>


<p>如下图：</p>

<p><img src="http://wibud.github.io/images/private/TheGPUProcess.png" alt="" /></p>

<h3>命令缓冲区（The Command Buffer）</h3>

<p>The commands accepted by the GPU process are patterned closely after the GL ES 2.0 API (for example there&rsquo;s a command corresponding to glClear, one to glDrawArrays, etc).因为大部分的GL调用没有返回值，客户端和服务端的工作方式基本上是异步的，而这种方式的性能会比较低。所以客户端和服务端就需要进行一些必要的同步，比如客户端通知服务端进行一些额外的工作，这种同步是通过IPC（Inter-Process Communication，进程间通信）机制实现的。</p>

<p>从客户端的角度来说，应用程序可以直接将命令写入命令缓冲区，或者通过客户端的库（处理序列化的）来使用GL ES 2.0 API。为方便起见，合成器和WebGL都是使用客户端库&ndash;GL ES。在服务端，命令会被转化成对OpenGL或者Direct3D的调用。</p>

<h3>资源共享与同步（Resource Sharing &amp; Synchronization）</h3>

<p>除了为命令缓冲区提供存储，Chrome还使用共享内存在客户端（Render进程）和服务端（GPU进程）间传递较大的资源（比如：纹理texture[5]的位图、顶点数组等等）。</p>

<p>还有一个被称为<a href="http://src.chromium.org/viewvc/chrome/trunk/src/gpu/GLES2/extensions/CHROMIUM/CHROMIUM_texture_mailbox.txt">mailbox</a>的结构，提供了一种在命令缓冲区和纹理生命周期管理之间共享纹理的方式。mailbox是一个简单的字符串标识符，用来标示纹理的id，之后可以使用这个纹理id的别名来访问纹理。每一个被标示的纹理id代表了一个底层真正的纹理，删除了纹理id，那么真正的纹理也会被销毁。</p>

<p><a href="http://src.chromium.org/viewvc/chrome/trunk/src/gpu/GLES2/extensions/CHROMIUM/CHROMIUM_sync_point.txt">Sync points</a>提供一种不阻塞的同步方式，可以使命令缓冲区之间通过mailbox共享纹理。在命令区A上插入一个sync point，同时将命令区B上的sync point处于“等待wait”状态，这样可以保证，之后插入到B中得命令在A插入sync point前的命令执行完成前，是不会得到执行的。</p>

<h3>命令缓冲区复用（Command Buffer Multiplexing）</h3>

<p>现在，Chrome中，每一个浏览器实例、Render进程的所有服务请求以及任何的插件进程都会使用唯一的一个GPU进程。GPU进程可以在多个命令缓冲区之间复用，并且每一个命令缓冲区都有一个自己的渲染上下文。</p>

<p>每个合成器都有多个GL源，比如WebGL Canvas元素就可以直接产生GL命令流。层（由GPU直接创建内容的层）的合成流程如下：层会render进纹理中（使用Frame Buffer对象），当render GraphicsLayer时，合成器上下文可以抓取和使用这些纹理。值得注意的是，为了能让合成器的GL上下文访问到由屏幕外的GL上下文（比如被其他GraphicsLayer的FBO使用的GL上下文）产生的纹理，所有GPU进程使用的GL上下文都可以共享资源。</p>

<p>体系结构如下图所示：</p>

<p><img src="http://wibud.github.io/images/private/HandlingMultipleContexts.png" alt="" /></p>

<h3>总结</h3>

<p>GPU进程体系有如下的好处：</p>

<ul>
<li>安全：render的逻辑大部分在沙盒渲染进程中，平台3D API的访问权限只对GPU进程开放。</li>
<li>鲁棒：GPU进程档掉并不会使浏览器挂掉。</li>
<li>一致性：作为浏览器渲染API的OpenGL ES 2.0是标准化的，跨平台的。</li>
<li>并行：Render进程可以快速 的将命令发给命令缓冲区，并且返回到CPU密集的render活动中，留给GPU进程去处理这些命令。我们可以充分利用多内核机器上的GPU进程和CPU进程。</li>
</ul>


<p>接下来，我们将介绍合成器是如何产生GL命令和资源的。</p>

<h2>Part 3：合成线程（The Threaded Compositor）</h2>

<p>合成器是在GL ES 2.0客户端库基础上实现的，GL ES 2.0会使用之前提到的方法将图形调用代理到GPU进程中。当页面通过合成器渲染时，它的像素点会通过GPU进程直接draw（draw != paint）进窗口的backbuffer。</p>

<p>合成器的体系结构随时间而演变：最初，它在Renderer主线程中，然后转移到了自己的线程中（也就是所谓的合成线程），当发生paint（也就是所谓的impl-side painting）时，承担了排版（orchestrating）任务。</p>

<p>理论上来说，线程化的合成器，应该是从主线程中获取足够的信息，然后独立的产生帧，用以响应用户输入。实际上，这意味着，它要根据视口当前位置的层的区域来备份cc layer树和SkPicture。</p>

<h3>Recording: Painting from Blink&rsquo;s Perspective</h3>

<p>interest area表示SkPictures记录的视口的范围区域。当DOM发生变化时（比如一些元素的样式同之前主线程中的帧不同，且已经invalidate（需要repaint）），Blink引擎通过将intereat area放入 SkPicture-backed GraphicsContext中，来paint这些invalidated的层的区域。这实际上并不产生新的像素，而是产生一个display list，里面存储这产生这些新像素的Skia命令。之后这个display list可以在合成器中使用，来产生新的像素。</p>

<h3>切换到合成线程（The Commit: Handoff to the Compositor Thread）</h3>

<p>线程化的合成器的一个关键的特性是他可以在主线程状态的副本上进行操作，这样就可以无需向主线程请求，来产生帧。合成器有两部分：主线程部分和impl部分（合成线程的一部分）。主线程有一个LayerTreeHost（是layer tree的副本），impl线程有一个LayerTreeHostImpl（是layer tree的副本）。</p>

<p>理论上，这两个layer tree是完全分开的，并且合成（impl）线程可以在不与主线程有任何交互的情况下产生帧。这意味着主线程可以专注于运行javascript，而合成器依然可以redraw之前提交给GPU的内容而不被阻塞。</p>

<p>为了产生新的帧，合成线程需要知道如何改变它的状态（比如更新scroll事件对应的层的变换）。因此，一些输入事件（比如scroll）会首先从浏览器进程转移到合成器，然后从合成器转交给Renderer主线程。通过控制输入和输出，合成器可以保证对用户输入进行视觉响应。除了scroll滚动，合成器执行一些页面更新（目前只有CSS 动画和CSS滤镜）而不需要请求Blink引擎进行repaint。</p>

<p>主线程的LayerTreeHost和impl线程的LayerTreeHostImpl，这两个layer tree由被称为commit的消息来保持同步，这些消息由合成器的调度程序（cc/trees/thread_proxy.cc中）进行管理和调度。commit会将主线程的状态（包括更新过的layer tree和新的SkPicture记录等等）传递给合成线程。这种同步是会阻塞主线程的。这是产生特定帧过程中，有主线程参与的最后一步。</p>

<p>将合成器运行在独立的线程中，可以让合成器用layer tree的副本来更新层的transform hierarchy，而不需要涉及到主线程。但是主线程还是需要知道一些信息比如滚动偏移量等等，（这样javascript才可以知道页面滚动到哪）。因此，commit消息还负责将合成线程中得layer tree更新到主线程中。</p>

<p>有趣的是，这种体系结构导致了javascript的touch事件处理程序（调用preventDefault()）可以阻止滚动，而scroll事件的处理程序却不可以。如果javascript可能要取消touch事件，那么合成器在请求javascript（运行在主线程中）前是不会滚动页面的。另一方面，scroll事件不能被阻止并且会异步的传给javascript，因此，合成线程会立刻开始滚动，而不管主线程是否立刻处理滚动事件。</p>

<h3>激活树（Tree Activation）</h3>

<p>当合成线程从主线程那里得到一个新的layer tree以后，合成线程会检查树中的invalid区域，并且换重新栅格化树中得layer。在此期间，active tree会保存之前在合成线程中老的layer tree，而pending tree是新的要被栅格化的树。</p>

<p>为保证显示内容的一致性，pending tree只有它的可见的（比如出现在视口中）高分辨率的内容完全栅格化以后才能被激活（avtivate）。从一个当前active tree切换到一个ready的pending tree的过程成为activation（激活）。等待栅格化内容准备的过程意味着用户通常可以看到一些可能过时的内容。如果没有内容可用，Chrome会显示通过GL着色器产生的空白或者盘格（checkerboard）图案来代替。</p>

<p>值得注意的是，因为Chrome只记录在interest area中的layer区域的SkPicture，所以有可能会滚动出active tree的栅格区域。如果用户朝着一个unrecorded区域滚动，合成器会请求主线程record和commit额外内容（additional content），但是，如果新的内容没有及时的recode、commit、栅格化（rasterize）以激活，用户会滚动到一个checkerboard区域。</p>

<p>为了减轻上述出现checkerboard的情况，Chrome可以在栅格化pending tree高分辨率内容之前先快速的将其栅格化为低分辨率的内容。持有可以被视口所用的低分辨率的内容的pending tree，如果它的持有的内容比当前屏幕上的好（比如，相应的active tree没有针对当前视口的完全栅格化的内容时），那么这个pending tree就会被激活。切片（tile）管理程序（下文会讲到）决定什么内容在什么时候栅格化。</p>

<p>这种体系结构将栅格化从帧生产流程中剥离出来。它促进了很多提升图形系统响应速度的技术。图片的解码和缩放操作是异步的，而这在之前是在pain过程中执行的昂贵的主线程操作。</p>

<h3>切片（Tiling）</h3>

<p>栅格化整个layer十分浪费CPU时间（paint操作的时间）和内存（RAM for any software bitmaps the layer needs; VRAM for the texture storage）。合成器会将大部分web content layer分解为切片（tile），并且在这些切片的基础上栅格化层。</p>

<p>Web content layer tiles根据一系列因素来确定优先级，包括，靠近视口的程度和在屏幕上显示的预估时间。GPU内存会根据切片的优先级分配给切片，之后切换会根据优先级，栅格化，并存储到可用的内存空间中。查阅<a href="https://docs.google.com/a/chromium.org/document/d/1tkwOlSlXiR320dFufuA_M-RF9L5LxFWmZFg5oW35rZk/edit#"> Tile Prioritization Design Doc</a>了解更多。</p>

<p>值得注意的是，对于那些内容已经驻留在GPU上的层（比如accelerated video和WebGL），就不需要切片了。</p>

<h3>栅格化（Rasterization）: Painting from cc/Skia’s perspective</h3>

<p>合成线程中的SkPicture转换成GPU上的位图有两种方式：</p>

<ul>
<li>由Skia的software rasterizer paint进位图中，然后作为纹理上传到GPU中</li>
<li>由Skia的 OpenGL backend (Ganesh)直接paint进GPU上的纹理中</li>
</ul>


<p>对于Ganesh-rasterized layers，the SkPicture is played back with Ganesh 然后所得的GL命令流会通过命令缓冲区交给GPU进程处理。当合成器决定栅格化切片时，会立刻产生GL命令，同时切片会捆绑在一起处理，防止栅格切片时，GPU的过高消耗。看这里<a href="https://docs.google.com/a/chromium.org/document/d/1Vi1WNJmAneu1IrVygX7Zd1fV7S_2wzWuGTcgGmZVRyE/edit?usp=drive_web"> GPU accelerated rasterization design doc</a>了解更多。</p>

<p>对于software-rasterized的层来说，会paint进共享内存（由Render进程和GPU进程）里的位图中。位图会通过之前介绍的资源转移机制交给GPU进行处理。由于software rasterization的性能代价十分昂贵，所以rasterization不会在合成线程中进行（否则它会阻塞active tree的新一帧的drawing），而是在compositor raster worker线程中进行。多个raster worker 线程可用于加快software rasterization。最终的切片会作为纹理上传到GPU。</p>

<p>位图的纹理上传受平台的内存带宽限制。纹理上传会影响software-rasterized layer的性能，并且会影响需要hardware rasterizer（硬件栅格化）的位图（比如image data或者CPU-rendered masks）的上传。过去，chrome有许多不同的纹理上传机制，但是最成功的还是异步上传（asynchronous uploader），这种机制，将上传放在GPU进程的一个worker线程中（对于android来说，是在浏览器进程的一个additional线程中），这样，其他操作就不会阻塞可能长时间的纹理上传。</p>

<p>有一个彻底解决纹理上传问题的方法，就是在unified memory architecture设备上使用CPU和GPU共享的zero-copy buffers。Chrome目前还没有使用，不过未来会得。更多看这里<a href="https://docs.google.com/document/d/1SaTYTBvHWWDKA3MPJPpQ-79RNgdS4Xu4g3KiD39VQjU/edit?usp=sharing">GpuMemoryBuffer design doc</a></p>

<p><img src="http://wibud.github.io/images/private/CompositingwiththeGPUprocess.png" alt="" /></p>

<h3>Drawing on the GPU, Tiling, and Quads</h3>

<p>一旦所有的纹理填充完毕，那么接下来就简单了，对layer的层次结构做深度优先遍历，然后发出GL命令，将每一个layer的纹理draw进frame buffer（帧缓冲器）中。</p>

<p>在屏幕上draw一个层，其实就是draw它的每一个切片。切片被表示成quad（简单的四边形，比如矩形），这些quads绘制填充的是给定层的内容的一个分区。合成器会生成quads和一组render passes（渲染通道，存储quads列表的简单的数据结构）。drawing的实际GL命令的产生同quads的产生是分离的（详见cc/output/gl_renderer.cc）。drawing quads或多或少要为每一个render pass建立一个viewport和transform，并且要绘制（draw）rander pass的quad list中的每一个quad。</p>

<h3>Varied Scale Factors（多种比例因素）</h3>

<p>impl-side painting的一个显著的优点就是，合成器可以以任意的比例reraster（栅格化）已存在的SkPictures。这在两种情形下十分有用：双指缩放和在fast fling（快速滚动）期间产生低分辨率切片。</p>

<p>合成器会拦截pinch/zoom的输入事件，并且在GPU上按适当比例缩放已经栅格化（按最合适的分辨率）的切片。每当这个新的切片准备好了（被栅格化且上传），通过激活pending tree和提高pinch/zoom的屏幕的分辨率，这些切片会被swap in。</p>

<p>当由software进行栅格化时，如果在滚动过程中，高分辨率的切片没有准备好，那么compositor也会试图快速的产生低分辨率的切片（对paint负担较小），并且先展示低分辨率的这些。这就是为什么一些页面在快速滚动过程中看起来会模糊&mdash;合成器将低分辨的切片展示到了屏幕上。</p>

<h2>附录</h2>

<h3>The Software Compositor（软件合成器）</h3>

<p>在某些情况下，硬件合成是不可行的，比如一个设备的图形驱动被加入了黑名单或者压根就没有GPU。对于这些情况，另一种替代GL renderer的实现称为SoftwareRenderer（详见src/cc/output/software_renderer）。总的来说，Chrom除了需要访问GPU的那些操作，software和硬件上的功能大体相同，但在实现上有如下几个关键的不同点：</p>

<ul>
<li><p>它会把quad留存在系统内存中，并以共享内存的形式传递他们，而不是将quad作为纹理上传到GPU中</p></li>
<li><p>software renderer使用Skia的software rasterizer来复制内容纹理（content texture）到backbuffer中，并且会执行一些必要的matrix math和clipping。而不是使用GL。</p></li>
</ul>


<h3>术语表</h3>

<p>[1] compositing：将RenderLayer的纹理（texture）合成为最终屏幕上的图片</p>

<p>[2] drawing：将像素点绘制到屏幕上（将最终的屏幕画面放到屏幕上）的render阶段</p>

<p>[3] painting：RenderObjects调用GraphicsContext API生成相应的视觉展现的render阶段。生成元素呈现的像素，例如，一个有着灰色背景，有文字的元素，当浏览器paint它时，是决定哪些像素填充背景，哪些像素填充文字，然后浏览器将这些像素存入位图（bitmap）中。</p>

<p>[4] bitmap：内存或显存中一组像素值</p>

<p>[5] texture：应用于GPU 3D模型上的位图（bitmap）</p>

<p>[6] invalidation：标记为dirty的文档区域，一般表示该区域需要repainting。样式系统（style system）也有相同的概念。</p>

<p>[7] rasterization：位图（backing up RenderLayers）填充（fill）的rendering阶段。当RenderObjects调用GraphicsContext时会立即发生rasterization。或者当我们使用SkPicture record来painting且使用SkPicture playback来rasterization时，会发生rasterization。</p>

<p>[8] texture quad：应用于四个点多边形（比如矩形）的这种简单模型的纹理。</p>

<p>[9] backbuffer：when double-buffering, the screen buffer that’s rendered into, not the one that’s currently being displayed</p>

<p>[10] frontbuffer：when double-buffering, the screen buffer that’s currently being displayed, not the one that’s currently being rendered into</p>

<h3>From WebKit to the Screen</h3>

<p><img src="http://wibud.github.io/images/private/SoftwareRenderingArchitecture.png" alt="" /></p>

<p>一旦所有的RenderLayers都paint进共享位图中，依然需要将位图放到屏幕上。在chrom中，位图驻留在共享内存中并且通过IPC传给浏览器进程。浏览器进程会通过操作系统的windowing APIs（比如windows的相关HWND），将位图draw到相应的选项卡或窗口中</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript严格模式详解]]></title>
    <link href="http://wibud.github.io/blog/2014/01/09/javascriptyan-ge-mo-shi-xiang-jie/"/>
    <updated>2014-01-09T15:17:48+08:00</updated>
    <id>http://wibud.github.io/blog/2014/01/09/javascriptyan-ge-mo-shi-xiang-jie</id>
    <content type="html"><![CDATA[<h2>一、简介</h2>

<p>严格模式（strict mode）是在ES5（ECMAScript 5）中引入的一种新的JavaScript运行模式，该模式下，禁止了很多JavaScript中问题较多、容易出错、影响应能的特性，目的是让JavaScript在更为严格的条件下运行，减少怪异行为和语言不合理的地方，提高编译运行性能（比如禁用with语句），增强了代码本身的安全性。</p>

<p>在ES5之前的版本是不支持严格模式的，但是严格模式有很好的向后兼容性，因为低版本标准的引擎会忽略严格模式的声明，这个会在之后进行介绍。</p>

<p>想了解各浏览器对于严格模式的支持情况戳这里<a href="http://kangax.github.io/es5-compat-table/">ECMAScript 5 compatibility table</a>，其中还统计了ES5新增特性的兼容情况。</p>

<h2>二、声明</h2>

<p>声明调用严格模式十分简单，也有些怪异，使用字符串字面量：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>之所以使用字符串字面量好处就是可以向后兼容，对于不支持严格模式的引擎，执行这条语句没有任何作用和影响。当然，如果我们使用了严格模式，那么就需要使用支持严格模式的引擎进行测试，使用低版本的引擎无法检测出严格模式下的错误。</p>

<p>声明方式有如下两种：</p>

<ul>
<li>1、声明整个脚本</li>
</ul>


<p>将<code>"use strict;"</code>在脚本文件第一行，且必须是第一行，否则严格模式将无效。</p>

<blockquote><p>在<code>"use strict;"</code>前不能有任何执行语句，即使是一个空的分号，都会使严格模式失效。</p></blockquote>

<p><code>&lt;script&gt;</code>包含的脚本块和引入的外部文件对于严格模式来说都是相互独立的，也就是说，一个脚本块或脚本文件设置成严格模式执行，并不会影响到其他的脚本块和脚本文件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;严格模式&quot;</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/script&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;正常模式&quot;</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>2、声明单个函数体</li>
</ul>


<p>单个函数的声明和整个脚本的类似，需要将<code>"use strict;"</code>放在函数体的第一行。这样该函数就会以严格模式运行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">f</span><span class="p">(){</span>
</span><span class='line'>    <span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>在大型多人合作的项目中使用严格模式，就需要多加注意了。因为，在开发中可能使用了多个脚本文件，而在部署时，会将多个文件合并成一个，如果有的脚本文件使用严格模式，而有的并没有使用，那么合并起来就可能导致意想不到的问题。比如，需要使用严格模式的地方失效了，而不需要使用严格模式的地方反而运行在严格模式下了。</p>

<p>对于此类问题，有如下两种的解决方法：</p>

<ul>
<li>1、不将严格模式运行的文件和正常模式运行的文件合并起来。</li>
</ul>


<p>这应该是最简单的解决方法了，那么你在部署的时候就至少需要两个独立的脚本文件。但这样无疑会对你的文件管理增加负担。</p>

<ul>
<li>2、使用独立作用域（立即调用的函数表达式）</li>
</ul>


<p>将脚本文件内容包含再立即调用的函数表达式中，就好像模块一样。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>    <span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">f</span><span class="p">(){</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">})();</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样合并成一个文件以后就不会相互影响了</p>

<h2>三、严格模式的限制</h2>

<p>以下列出了严格模式最主要的限制。</p>

<ul>
<li>1、变量必须使用var声明</li>
</ul>


<p>正常模式下，未声明的变量，默认是全局变量，而在严格模式下，必须对变量进行声明，否则会报错：“SCRIPT5042：严格模式下未定义变量”。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="nx">testValue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 报错</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>    <span class="c1">// 报错</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>2、禁止写入只读属性</li>
</ul>


<p>正常模式下，对对象的只读属性进行赋值，不会出现错误，只是会默认失效，而在严格模式下，写入只读属性（包括使用get进行读取的属性）会报错：“SCRIPT5045：严格模式下不允许分配到只读属性”。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">testObj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperties</span><span class="p">({},</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">prop1</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">value</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span>
</span><span class='line'>        <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span> <span class="c1">// by default</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>    <span class="nx">prop2</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="nx">testObj</span><span class="p">.</span><span class="nx">prop1</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>     <span class="c1">// 报错</span>
</span><span class='line'><span class="nx">testObj</span><span class="p">.</span><span class="nx">prop2</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>     <span class="c1">// 报错</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>3、禁止为不可扩展的对象新增属性</li>
</ul>


<p>正常模式下，为不可扩展的对象添加属性不会报错，只会默认失效，而在严格模式下，会报错：“SCRIPT5046：无法为不可扩展的对象创建属性”。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">testObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
</span><span class='line'><span class="nb">Object</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">testObj</span><span class="p">);</span>
</span><span class='line'><span class="nx">testObj</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&quot;Bob&quot;</span><span class="p">;</span>   <span class="c1">// 报错</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>4、禁止删除变量、函数、参数和configurable为false的属性</li>
</ul>


<p>在严格模式下，只有configurable特性设置为true的对象属性才可以被删除，否则将报错：“SCRIPT1045：严格模式下不允许对 &lt;表达式> 调用 Delete”。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">testvar</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">testFunc</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'><span class="k">delete</span> <span class="nx">testvar</span><span class="p">;</span>     <span class="c1">// 报错</span>
</span><span class='line'><span class="k">delete</span> <span class="nx">testFunc</span><span class="p">;</span>    <span class="c1">// 报错</span>
</span><span class='line'>
</span><span class='line'><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">testObj</span><span class="p">,</span> <span class="s2">&quot;testvar&quot;</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">value</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">configurable</span><span class="o">:</span> <span class="kc">false</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="k">delete</span> <span class="nx">testObj</span><span class="p">.</span><span class="nx">testvar</span><span class="p">;</span>     <span class="c1">// 报错</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>5、禁止对象属性名重复</li>
</ul>


<p>正常模式下，如果对象的属性名重复，那么后一个属性的值会覆盖前一个同名属性的值，而在严格模式下，如果对象有同名属性，则会报错：“SCRIPT1046：严格模式下不允许一个属性有多个定义”。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">testObj</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">prop1</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">prop2</span><span class="o">:</span> <span class="mi">15</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">prop1</span><span class="o">:</span> <span class="mi">20</span>
</span><span class='line'><span class="p">};</span>  <span class="c1">// 报错</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>6、禁止函数参数名重复</li>
</ul>


<p>正常模式下，如果函数有多个重名参数，则可以使用argument[i]来读取相应的参数，而在严格模式下，如果函数存在参数重名，则会报错：“SCRIPT1038：严格模式下不允许正式参数名称重复”。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">testFunc</span><span class="p">(</span><span class="nx">param1</span><span class="p">,</span> <span class="nx">param1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>  <span class="c1">// 报错</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>7、保留关键字</li>
</ul>


<p>为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。</p>

<p>在严格模式下，使用这些这些保留字做变脸或函数名都会报错：“SCRIPT1050：无法使用标识符的未来保留字。 严格模式下将保留标识符名称。”</p>

<blockquote><p>此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。</p></blockquote>

<ul>
<li>8、禁止八进制数值</li>
</ul>


<p>正常模式下，整数数值的第一位如果是0，表示是八进制数，而在严格模式下，禁止对数值文本分配八进制值，或尝试对八进制值使用转义，否则报错：“SCRIPT1039：严格模式下不允许使用八进制数字参数和转义字符”。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">testoctal</span> <span class="o">=</span> <span class="mi">010</span><span class="p">;</span>    <span class="c1">// 报错</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">testescape</span> <span class="o">=</span> <span class="err">\</span><span class="mi">010</span><span class="p">;</span>  <span class="c1">// 报错</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>9、禁止this指向全局对象</li>
</ul>


<p>在严格模式下，当 this 的值为 null 或 undefined 时，该值不会转换为全局对象，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">testFunc</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">testvar</span> <span class="o">=</span> <span class="nx">testFunc</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>在正常的模式下，testvar的值为全局对象，但在严格模式下，该值为 undefined。</p>

<p>再比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">f</span><span class="p">(){</span>
</span><span class='line'><span class="err">　　　　</span><span class="k">return</span> <span class="o">!</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'><span class="err">　　</span><span class="p">}</span>
</span><span class='line'><span class="err">　　</span><span class="c1">// 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是false</span>
</span><span class='line'><span class="err">　　</span><span class="kd">function</span> <span class="nx">f</span><span class="p">(){</span>
</span><span class='line'><span class="err">　　　　</span><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="err">　　　　</span><span class="k">return</span> <span class="o">!</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'><span class="err">　　</span><span class="p">}</span>
</span><span class='line'><span class="err">　　</span><span class="c1">// 返回true，因为严格模式下，this的值为undefined，所以&quot;this&quot;为true。</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">f</span><span class="p">(){</span>
</span><span class='line'><span class="err">　　　　</span><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="err">　　　　</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="err">　　</span><span class="p">}</span>
</span><span class='line'><span class="err">　　</span><span class="nx">f</span><span class="p">();</span><span class="c1">// 报错，this未定义</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是在IE10的PP2版（支持严格模式）中对于严格模式下得this存在bug，对于<code>(function(){ "use strict"; return !this })()</code>返回的是false。</p>

<ul>
<li><p>10、禁止“eval”用作标示符（变量、函数名、参数名等）</p></li>
<li><p>11、eval具有独立作用域</p></li>
</ul>


<p>正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">indirectEval</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">;</span>
</span><span class='line'><span class="nx">indirectEval</span><span class="p">(</span><span class="s2">&quot;var testvar = 10;&quot;</span><span class="p">);</span>
</span><span class='line'><span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">testVar</span><span class="p">);</span>    <span class="c1">// 报错，testVar未定义</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>12、禁止在语句或块内声明函数</li>
</ul>


<p>严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数，否则将会报错：“SCRIPT1047：在严格模式下，函数声明无法嵌套在语句或块中。 它们只能显示在顶级或直接显示在函数体中。”</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="nx">index</span> <span class="k">in</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">myFunc</span><span class="p">()</span> <span class="p">{};</span>   <span class="c1">// 报错</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>13、禁止“arguments”用作标示符（变量、函数名、参数名等）</p></li>
<li><p>14、禁止对arguments对象赋值</p></li>
<li><p>15、arguments不再影响和追踪参数值</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="err">　　</span>  <span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="err">　　</span>  <span class="nx">a</span><span class="o">++</span><span class="err">；</span>
</span><span class='line'><span class="err">　　</span>  <span class="k">return</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
</span><span class='line'><span class="err">　　</span> <span class="p">}</span>
</span><span class='line'><span class="err">　　</span><span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// [2,1]</span>
</span><span class='line'><span class="err">　　</span>
</span><span class='line'><span class="err">　　</span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="err">　　</span>  <span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="err">　　</span>  <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="err">；</span>
</span><span class='line'><span class="err">　　</span>  <span class="k">return</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
</span><span class='line'><span class="err">　　</span> <span class="p">}</span>
</span><span class='line'><span class="err">　　</span> <span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>    <span class="c1">// [1,2]</span>
</span></code></pre></td></tr></table></div></figure>


<p>在严格模式下，arguments对象只是一个本地副本。</p>

<ul>
<li>16、禁止使用arguments.callee</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'><span class="err">　　</span><span class="nx">f</span><span class="p">();</span> <span class="c1">// 报错</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>17、禁止使用with</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>
</span><span class='line'><span class="err">　　</span><span class="kd">with</span> <span class="p">(</span><span class="nb">Math</span><span class="p">){</span>
</span><span class='line'>    <span class="nx">x</span> <span class="o">=</span> <span class="nx">cos</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">y</span> <span class="o">=</span> <span class="nx">tan</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress主题]]></title>
    <link href="http://wibud.github.io/blog/2013/12/20/octopresszhu-ti/"/>
    <updated>2013-12-20T17:52:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/12/20/octopresszhu-ti</id>
    <content type="html"><![CDATA[<p>在Octopress默认主题的基础上进行了一些修改，把nav移到了顶端，同时在左侧增加了展示用户信息的sidebar。当浏览器宽度小于1152时，添加了响应式的布局。</p>

<p>源码地址：<a href="https://github.com/wibud/Octopress-Theme-WinterBud">github</a></p>

<p>如果对主题感兴趣，安装方式如下：</p>

<pre><code>$ cd octopress
$ git clone git://github.com/wibud/Octopress-Theme-WinterBud.git .themes/WinterBud
$ rake install['WinterBud']
$ rake generate
</code></pre>

<p><img src="http://wibud.github.io/images/private/blog-screen.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GET和POST请求]]></title>
    <link href="http://wibud.github.io/blog/2013/08/05/gethe-postqing-qiu/"/>
    <updated>2013-08-05T11:12:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/08/05/gethe-postqing-qiu</id>
    <content type="html"><![CDATA[<h3>GET请求</h3>

<p>GET是最常见的请求类型，最常用于向服务器查询信息。如果要发送信息给服务器的话，需要将查询字符串参数追加到URL的末尾。</p>

<p>使用GET请求经常会发生一个错误，就是查询字符串参数的格式有问题。对于Javascript来说查询字符串中每个参数的名称和值都必须使用<code>encodeURIComponent()</code>进行编码，然后才能放到URL的末尾。</p>

<h3>POST请求</h3>

<p>POST通常用于向服务器发送应该被保存的数据。POST请求把数据作为请求的主体提交。POST请求的主体可以包含非常多的数据，而且格式不限。</p>

<h3>GET和POST的区别</h3>

<ul>
<li>GET只要是用来查询数据；POST主要用来提交数据</li>
<li>GET提交的数据是缀到URL末尾的，GET方式值发送HTTP消息头，没有消息体；POST的提交的数据是在消息体中</li>
<li>GET提交的数据量小，因为URL长度有限制；POST能提交大量数据</li>
<li>GET消耗的资源少；POST消耗的资源多</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cookie与session]]></title>
    <link href="http://wibud.github.io/blog/2013/08/03/cookieyu-session/"/>
    <updated>2013-08-03T11:11:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/08/03/cookieyu-session</id>
    <content type="html"><![CDATA[<h2>Cookie</h2>

<p>HTTP Cookie，通常直接叫做cookie，是在客户端用户存储会话信息的。cookie存储的信息是由服务器经HTTP头作为响应发给客户端的。例如服务器相应可能如下：</p>

<pre><code>HTTP/1.1 200 OK
Content-type:text/html
Set-Cookie:name=value
</code></pre>

<p>其中的<code>Set-Cookie</code>包含着会话信息，浏览器会存储这些会话信息，之后会为每个请求添加Cookie HTTP头，将信息发送回服务器，如下</p>

<pre><code>GET /index.html HTTP/1.1
Cookie:name=value
</code></pre>

<p>因为Cookie是存储在浏览器上，浏览器资源有限，所以Cookie的个数和大小会有限制，不同的浏览器对Cookie 的限制不同，有的限制每个域只能有20个Cookie，且每个域Cookie总大小限制在4095B，有的浏览器可能会多些。</p>

<h3>Cookie构成</h3>

<ul>
<li>名称：唯一确定cookie，名称是不区分大小写的</li>
<li>值：存储在cookie中的字符串的值，必须被URL编码</li>
<li>域：表示cookie对哪个域是有效的，所有向该有效域发送的请求都会加上这个cookie信息。如果没有设置，默认是设置cookie的域</li>
<li>路径：对于制定域中的那个路径，应该向服务器发送cookie</li>
<li>失效时间：表示cookie应该何时被删除。如果不设定，默认情况下，浏览器会话结束就会删除cookie（会话cookie）。如果设置了时间（大于当前时间），则浏览器关闭后cookie依然会保存在用户机器上（持久cookie）。这个值是GMT格式的日期。</li>
<li>安全标志</li>
</ul>


<h3>Javascript操作cookie</h3>

<p> <code>document.cookie</code>属性返回当前页面可用的（根据cookie的域、路径、失效时间和安全设置）所有cookie的字符串，一系列由分号分隔的名值对，如下：</p>

<pre><code>name1=value1;name2=value2;name3=value3
</code></pre>

<p>所有名字和值都是URL编码的，所以必须使用<code>decodeURIComponent()</code>解码。</p>

<p>设置值得时候，可以直接给<code>document.cookie</code>属性赋值，并不会覆盖cookie，除非设置的cookie名称已经存在。</p>

<p>由于cookie操作比较麻烦，并不直观，下面来看一个简化cookie操作的功能对象：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'>    <span class="kd">var</span> <span class="nx">CookieUtil</span><span class="o">=</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
</span><span class='line'>            <span class="kd">var</span> <span class="nx">cookieName</span> <span class="o">=</span> <span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;=&quot;</span><span class="p">,</span>
</span><span class='line'>                <span class="nx">cookieStart</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">indexof</span><span class="p">(</span><span class="nx">cookieName</span><span class="p">);</span>
</span><span class='line'>                <span class="nx">cookieValue</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="nx">cookieStart</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span><span class='line'>                <span class="kd">var</span> <span class="nx">cookieEnd</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">indexof</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">,</span><span class="nx">cookieStart</span><span class="p">);</span>
</span><span class='line'>                <span class="k">if</span><span class="p">(</span><span class="nx">cookieEnd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span><span class='line'>                    <span class="nx">cookieEnd</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="nx">cookieValue</span> <span class="o">=</span> <span class="nb">decodeURIComponent</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">cookieStart</span><span class="o">+</span><span class="nx">cookieName</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">cookieEnd</span><span class="p">));</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">return</span> <span class="nx">cookieValue</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">expires</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">domain</span><span class="p">,</span> <span class="nx">secure</span><span class="p">){</span>
</span><span class='line'>            <span class="kd">var</span> <span class="nx">cookieText</span> <span class="o">=</span> <span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;=&quot;</span><span class="o">+</span><span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="nx">expires</span> <span class="k">instanceof</span> <span class="nb">Date</span><span class="p">){</span>
</span><span class='line'>                <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s2">&quot;; expires=&quot;</span> <span class="o">+</span> <span class="nx">expires</span><span class="p">.</span><span class="nx">toGMTString</span><span class="p">();</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="nx">path</span><span class="p">){</span>
</span><span class='line'>                <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s2">&quot;; path=&quot;</span> <span class="o">+</span> <span class="nx">path</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="nx">domain</span><span class="p">){</span>
</span><span class='line'>                <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s2">&quot;; domain=&quot;</span> <span class="o">+</span> <span class="nx">domain</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="nx">secure</span><span class="p">){</span>
</span><span class='line'>                <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s2">&quot;; secure&quot;</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">=</span> <span class="nx">cookieText</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<h2>Session</h2>

<p>Session机制是一种服务器端维持会话状态的机制。每个session唯一的由一个session id标示，session id是存储在客户端的，由客户端请求时发给服务器来与相应的session建立联系。</p>

<p>session id一般来说是保存在cookie中，当然如果cookie被禁用了，我们就需要其他的存储手段，比如：URL重写，就是把session id附加到URL路径的后面，还有一种技术叫表单隐藏字段，给表单添加一个隐藏字段。</p>

<h3>Session什么时候创建</h3>

<p>session是在服务器端程序调用HttpServletRequest.getSession(true)这样的语句时才被创建，而不是客户端访问的时候被创建的。</p>

<p>注意JSP如果没有显示的关闭session，会自动创建session。</p>

<h3>Session什么时候被删除</h3>

<ul>
<li>程序调用<code>HttpSession.invalidate()</code></li>
<li>session超时</li>
<li>服务器进程停止</li>
</ul>


<p>要注意的是session id一般是保存在会话cookie中，会话cookie会在浏览器关闭之后被删除，于是，相应的session id也会被删除，但是这时并不代表session也被删除了，服务器会一直保留session直到session处于非活动状态的时间超过了设置的超时时间，这时才会删除session。</p>

<h2>Cookie与Session的区别</h2>

<p>cookie机制采用的是在客户端保持状态的机制，cookie信息保存在客户端。cookie存储空间小。</p>

<p>session机制采用的是服务器端保持状态的机制，session信息保存在服务器端。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ajax相关总结]]></title>
    <link href="http://wibud.github.io/blog/2013/08/02/ajaxxiang-guan-zong-jie/"/>
    <updated>2013-08-02T11:09:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/08/02/ajaxxiang-guan-zong-jie</id>
    <content type="html"><![CDATA[<h3>创建XMLHttpRequest对象</h3>

<p>创建XMLHttpRequest对象，跨浏览器兼容：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'>    <span class="kd">function</span> <span class="nx">createXHR</span><span class="p">(){</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 如果支持原生XHR对象</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">XMLHttpRequest</span> <span class="o">!=</span> <span class="s2">&quot;undefined&quot;</span><span class="p">){</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// 兼容IE6和之前版本</span>
</span><span class='line'>        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">ActiveXObject</span> <span class="o">!=</span> <span class="s2">&quot;undefined&quot;</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// arguments.callee.activeXString存放版本信息</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">.</span><span class="nx">activeXString</span> <span class="o">!=</span> <span class="s2">&quot;string&quot;</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>                <span class="c1">// 可能有3中不同版本的XHR对象</span>
</span><span class='line'>                <span class="kd">var</span> <span class="nx">versions</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;MSXML2.XMLHttp.6.0&quot;</span><span class="p">,</span> <span class="s2">&quot;MSXML2.XMLHttp.3.0&quot;</span><span class="p">,</span> <span class="s2">&quot;MSXML2.XMLHttp&quot;</span><span class="p">],</span>
</span><span class='line'>                    <span class="nx">i</span><span class="p">,</span><span class="nx">len</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>                <span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nx">len</span><span class="o">=</span><span class="nx">versions</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>                    <span class="c1">// 如果不能创建相应版本的XHR对象，会抛异常，继续检查下一个版本</span>
</span><span class='line'>                    <span class="k">try</span><span class="p">{</span>
</span><span class='line'>                        <span class="k">new</span> <span class="nx">ActiveXObject</span><span class="p">(</span><span class="nx">versions</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
</span><span class='line'>                        <span class="c1">// 如果可以创建该版本的XHR对象，则记录版本</span>
</span><span class='line'>                        <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">.</span><span class="nx">activeXString</span> <span class="o">=</span> <span class="nx">versions</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span><span class='line'>                        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>                    <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">ex</span><span class="p">){</span>
</span><span class='line'>                        <span class="c1">// 没有操作</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">return</span> <span class="k">new</span> <span class="nx">ActiveXObject</span><span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">.</span><span class="nx">activeXString</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;No XHR object available&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>响应处理</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'>    <span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="nx">createXHR</span><span class="p">()</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// 必须在调用open()之前指定onreadystatechange事件处理才能确保跨浏览器的兼容性</span>
</span><span class='line'>    <span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystartechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>        <span class="c1">// 请求/响应过程完成</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">==</span> <span class="mi">4</span><span class="p">){</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="nx">httpSuccess</span><span class="p">(</span><span class="nx">xhr</span><span class="p">)){</span>
</span><span class='line'>                <span class="c1">// 响应的处理</span>
</span><span class='line'>            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>                <span class="c1">// 请求/响应不成功</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">&quot;get&quot;</span><span class="p">,</span> <span class="s2">&quot;example.txt&quot;</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">httpSuccess</span><span class="p">(</span><span class="nx">xhr</span><span class="p">){</span>
</span><span class='line'>        <span class="k">try</span><span class="p">{</span>
</span><span class='line'>            <span class="c1">// 如果得不到服务器状态，且我们正在请求本地文件，认为成功</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">!</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&amp;&amp;</span> <span class="nx">location</span><span class="p">.</span><span class="nx">protocol</span><span class="o">==</span><span class="s2">&quot;file:&quot;</span> <span class="o">||</span>
</span><span class='line'>
</span><span class='line'>                    <span class="c1">// 所有200到300间的状态码表示成功（包括200，不包括300）</span>
</span><span class='line'>                    <span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&lt;</span> <span class="mi">300</span><span class="p">)</span> <span class="o">||</span>
</span><span class='line'>
</span><span class='line'>                    <span class="c1">// 文档未修改也算成功</span>
</span><span class='line'>                    <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="mi">304</span> <span class="o">||</span>
</span><span class='line'>
</span><span class='line'>                    <span class="c1">// Safari 在文档未修改时返回空状态</span>
</span><span class='line'>                    <span class="nx">navigator</span><span class="p">.</span><span class="nx">userAgent</span><span class="p">.</span><span class="nx">indexof</span><span class="p">(</span><span class="s2">&quot;Safari&quot;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>                        <span class="k">typeof</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="s2">&quot;undefined&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">ex</span><span class="p">){}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<h4>常见的status返回码</h4>

<ul>
<li>403:Access Forbidden。通常是服务器上文件或目录的权限设置导致</li>
<li>404：Object not found。请求资源不存在</li>
<li>401：Access Denied。由于用户匿名访问使用的账号被禁用，或者没有权限访问计算机。</li>
<li>500：Internal Server Error。服务器发生错误。</li>
</ul>


<h3>AJAX跨域请求（CORS）</h3>

<p>跨浏览器的CORS：</p>

<pre><code>function createCORSRequest(method, url){
    var xhr = new XMLHttpRequest();
    // 检测XHR是否支持CORS
    if("withCredentials" in xhr){
        xhr.open(method, url, true);

    // 准对IE（IE8及之后版本）
    }else if(typeof XDomainRequest != "undefined"){
        xhr = new XDomainRequest();
        xhr.open(method, url);
    }else{
        xhr = null;
    }
    return xhr;
}

var request = createCORSRequest("get", "http://www.test.com/index");
if(request){
    // 请求返回会触发load事件
    request.onload = function(){
        // 操作
    };

    request.send();
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP头信息]]></title>
    <link href="http://wibud.github.io/blog/2013/07/27/httptou-xin-xi/"/>
    <updated>2013-07-27T11:08:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/07/27/httptou-xin-xi</id>
    <content type="html"><![CDATA[<p>当我们在浏览器的地址栏中输入了URL之后发生了什么？</p>

<ol>
<li>浏览器分析我们输入的地址，解析所要使用的协议为HTTP协议</li>
<li>浏览器向DNS请求解析URL的IP地址</li>
<li>域名系统DNS解析出所请求的URL服务器的IP地址</li>
<li>浏览器与服务器建立TCP连接</li>
<li>浏览器发出HTTP请求</li>
<li>服务器通过HTTP响应把文件返回给浏览器</li>
<li>浏览器将文件进行解释，并将web页显示给用户</li>
</ol>


<h3>HTTP头信息</h3>

<p>每个HTTP请求和响应都分为消息头和消息体两部分，而头部信息是一定会有的。</p>

<p>默认情况下HTTP请求会发送下列的头信息：</p>

<ul>
<li>Accept：浏览器能够处理的内容类型&ndash;content-type</li>
<li>Accept-Charset：浏览器能显示的字符集</li>
<li>Accept-Encoding：浏览器能处理的压缩编码</li>
<li>Accept-Language：浏览器当前设置的语言</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cookie：当前页面设置的任何Cookie</li>
<li>Host：发出请求的页面所在的域</li>
<li>Referer：发出请求的页面的URL</li>
<li>User-Agent：浏览器的用户代理字符串（包括浏览器类型、操作系统信息等）</li>
</ul>


<p>看一个例子：</p>

<pre><code>GET /index.html HTTP/1.1
Accept:application/x-shockwave-flash
Accept-Language:zh-cn
Accept-Encoding:gzip
Cookie:name=value
User-Agent:Mozilla/4.0
Host:localhost:8080
Connection:Keep-Alive
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[范式]]></title>
    <link href="http://wibud.github.io/blog/2013/07/15/fan-shi/"/>
    <updated>2013-07-15T11:04:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/07/15/fan-shi</id>
    <content type="html"><![CDATA[<h2>范式</h2>

<p>构造数据库必须遵循一定的规则。在关系数据库中，这种规则就是范式。范式是符合某一种级别的关系模式的集合。关系数据库中的关系必须满足一定的要求，即满足不同的范式。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、第四范式（4NF）、第五范式（5NF）和第六范式（6NF）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式（3NF）就行了。下面我们举例介绍第一范式（1NF）、第二范式（2NF）和第三范式（3NF）。</p>

<h3>第一范式（1NF）</h3>

<p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。所谓第一范式（1NF）是指</p>

<ul>
<li>数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。</li>
<li>在第一范式（1NF）中表的每一行只包含一个实例的信息。</li>
</ul>


<blockquote><p>简而言之，第一范式就是无重复的列。属性唯一</p></blockquote>

<h3>第二范式（2NF）</h3>

<blockquote><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。</p></blockquote>

<p>第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。</p>

<blockquote><p>简而言之，第二范式就是非主属性非部分依赖于主关键字。</p></blockquote>

<p>感觉很绕有没有？</p>

<p><strong>什么叫全部依赖，部分依赖？</strong>首先需要清楚一个概念，主关键字不是一个属性而是一组属性的集合，这个属性集合唯一的决定记录（实例）。现在再来看部分依赖，部分依赖就是主关键字这一组属性中的部分属性可以决定非主属性。</p>

<h3>第三范式（3NF）</h3>

<p>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</p>

<blockquote><p>简而言之，第三范式就是属性不依赖于其它非主属性。</p></blockquote>

<!-- more -->


<h2>范式的例子</h2>

<p>所谓范式就是符合某一种级别的关系模式的集合。通过分解把属于低级范式的关系模式转换为几个属于高级范式的关系模式的集合。这一过程称为规范化。</p>

<h3>第一范式（1NF）</h3>

<p>数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</p>

<h3>第二范式（2NF）</h3>

<p>数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</p>

<p>假定选课关系表为SelectCourse(学号, 姓名, 年龄, 课程名称, 成绩, 学分)，关键字为组合关键字(学号, 课程名称)，因为存在如下决定关系：</p>

<p>(学号, 课程名称) → (姓名, 年龄, 成绩, 学分)</p>

<p>这个数据库表不满足第二范式，因为存在如下决定关系：</p>

<p>(课程名称) → (学分)</p>

<p>(学号) → (姓名, 年龄)</p>

<p>即存在组合关键字中的字段决定非关键字的情况。</p>

<p>由于不符合2NF，这个选课关系表会存在如下问题：</p>

<p>　　(1) 数据冗余：</p>

<p>　　同一门课程由n个学生选修，&#8221;学分&#8221;就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。</p>

<p>　　(2) 更新异常：</p>

<p>　　若调整了某门课程的学分，数据表中所有行的&#8221;学分&#8221;值都要更新，否则会出现同一门课程学分不同的情况。</p>

<p>　　(3) 插入异常：</p>

<p>　　假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有&#8221;学号&#8221;关键字，课程名称和学分也无法记录入数据库。</p>

<p>　　(4) 删除异常：</p>

<p>　　假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。</p>

<p>　　把选课关系表SelectCourse改为如下三个表：</p>

<p>　　学生：Student(学号, 姓名, 年龄)；</p>

<p>　　课程：Course(课程名称, 学分)；</p>

<p>　　选课关系：SelectCourse(学号, 课程名称, 成绩)。</p>

<p>　　这样的数据库表是符合第二范式的，消除了数据冗余、更新异常、插入异常和删除异常。</p>

<p>　　另外，所有单关键字的数据库表都符合第二范式，因为不可能存在组合关键字。</p>

<h3>第三范式（3NF）</h3>

<p>在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如果存在&#8221;A → B → C&#8221;的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系：</p>

<pre><code>关键字段 → 非关键字段x → 非关键字段y
</code></pre>

<p>　　假定学生关系表为Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)，关键字为单一关键字&#8221;学号&#8221;，因为存在如下决定关系：</p>

<p>　　(学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话)</p>

<p>　　这个数据库是符合2NF的，但是不符合3NF，因为存在如下决定关系：</p>

<p>　　(学号) → (所在学院) → (学院地点, 学院电话)</p>

<p>　　即存在非关键字段&#8221;学院地点&#8221;、&#8221;学院电话&#8221;对关键字段&#8221;学号&#8221;的传递函数依赖。</p>

<p>　　它也会存在数据冗余、更新异常、插入异常和删除异常的情况，读者可自行分析得知。</p>

<p>　　把学生关系表分为如下两个表：</p>

<p>　　学生：(学号, 姓名, 年龄, 所在学院)；</p>

<p>　　学院：(学院, 地点, 电话)。</p>

<p>　　这样的数据库表是符合第三范式的，消除了数据冗余、更新异常、插入异常和删除异常。</p>

<h3>鲍依斯-科得范式（BCNF）</h3>

<p>在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合第三范式。</p>

<p>　假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：</p>

<p>　　(仓库ID, 存储物品ID) →(管理员ID, 数量)</p>

<p>　　(管理员ID, 存储物品ID) → (仓库ID, 数量)</p>

<p>　　所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：</p>

<p>　　(仓库ID) → (管理员ID)</p>

<p>　　(管理员ID) → (仓库ID)</p>

<p>　　即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。它会出现如下异常情况：</p>

<p>(1) 删除异常：</p>

<p>　　当仓库被清空后，所有&#8221;存储物品ID&#8221;和&#8221;数量&#8221;信息被删除的同时，&#8221;仓库ID&#8221;和&#8221;管理员ID&#8221;信息也被删除了。</p>

<p>　　(2) 插入异常：</p>

<p>　　当仓库没有存储任何物品时，无法给仓库分配管理员。</p>

<p>　　(3) 更新异常：</p>

<p>　　如果仓库换了管理员，则表中所有行的管理员ID都要修改。</p>

<p>　　把仓库管理关系表分解为二个关系表：</p>

<p>　　仓库管理：StorehouseManage(仓库ID, 管理员ID)；</p>

<p>　　仓库：Storehouse(仓库ID, 存储物品ID, 数量)。</p>

<p>　　这样的数据库表是符合BCNF范式的，消除了删除异常、插入异常和更新异常。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS hack]]></title>
    <link href="http://wibud.github.io/blog/2013/07/11/css-hack/"/>
    <updated>2013-07-11T11:02:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/07/11/css-hack</id>
    <content type="html"><![CDATA[<p>CSS hack方式很多，下面介绍几种常见的</p>

<h3>IE条件注释</h3>

<p>针对IE引入样式文件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="o">&lt;!</span><span class="nt">--</span><span class="o">[</span><span class="nt">if</span> <span class="nt">IE</span><span class="o">]&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="nt">link</span> <span class="nt">type</span><span class="o">=</span><span class="s2">&quot;text/CSS&quot;</span> <span class="nt">href</span><span class="o">=</span><span class="s2">&quot;ie.css&quot;</span> <span class="nt">rel</span><span class="o">=</span><span class="s2">&quot;stylesheet&quot;</span> <span class="o">/&gt;</span>
</span><span class='line'><span class="o">&lt;![</span><span class="nt">end</span> <span class="nt">if</span><span class="o">]</span><span class="nt">--</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>针对特定版本的IE:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="o">&lt;!</span><span class="nt">--</span><span class="o">[</span><span class="nt">if</span> <span class="nt">IE</span> <span class="nt">6</span><span class="o">]&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="nt">link</span> <span class="nt">type</span><span class="o">=</span><span class="s2">&quot;text/CSS&quot;</span> <span class="nt">href</span><span class="o">=</span><span class="s2">&quot;ie6.css&quot;</span> <span class="nt">rel</span><span class="o">=</span><span class="s2">&quot;stylesheet&quot;</span> <span class="o">/&gt;</span>
</span><span class='line'><span class="o">&lt;![</span><span class="nt">end</span> <span class="nt">if</span><span class="o">]</span><span class="nt">--</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>针对某个版本范围的IE:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="o">&lt;!</span><span class="nt">--</span><span class="o">[</span><span class="nt">if</span> <span class="nt">gte</span> <span class="nt">IE</span> <span class="nt">6</span><span class="o">]&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="nt">link</span> <span class="nt">type</span><span class="o">=</span><span class="s2">&quot;text/CSS&quot;</span> <span class="nt">href</span><span class="o">=</span><span class="s2">&quot;ie6.css&quot;</span> <span class="nt">rel</span><span class="o">=</span><span class="s2">&quot;stylesheet&quot;</span> <span class="o">/&gt;</span>
</span><span class='line'><span class="o">&lt;![</span><span class="nt">end</span> <span class="nt">if</span><span class="o">]</span><span class="nt">--</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中“lte“表示“小于等于”，“lt”表示“小于”，“gte”表示“大于等于”，“gt”表示“大于”，“！”表示“不等于”</p>

<h3>选择符前缀</h3>

<p>原理是在CSS选择符前加上一些只有特定浏览器才能识别的值，例如<code>* html</code>只对IE6及更低版本有效</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'>   <span class="o">&lt;</span><span class="nt">style</span> <span class="nt">type</span><span class="o">=</span><span class="s2">&quot;text/CSS&quot;</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="o">*</span> <span class="nt">html</span> <span class="nc">.test</span><span class="p">{</span><span class="k">width</span><span class="o">:</span><span class="m">100%</span><span class="p">;}</span>    <span class="c">/* 只对IE6及更低版本有效 */</span>
</span><span class='line'>   <span class="o">&lt;/</span><span class="nt">style</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>样式属性前缀</h3>

<p>在样式的属性名前加上只有特定浏览器下才能生效的前缀，例如”_“只在IE6下有效</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'>   <span class="o">&lt;</span><span class="nt">style</span> <span class="nt">type</span><span class="o">=</span><span class="s2">&quot;text/CSS&quot;</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="nc">.test</span><span class="p">{</span><span class="k">width</span><span class="o">:</span><span class="m">80px</span><span class="p">;</span> <span class="n">_width</span><span class="o">:</span><span class="m">70px</span><span class="p">;}</span>
</span><span class='line'>   <span class="o">&lt;/</span><span class="nt">style</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>子选择器hack</h3>

<p>使用子选择器hack，是使用了IE老版本不理解而现代浏览器能够理解的选择器，这样在IE老版本就会忽略。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'>  <span class="nt">html</span><span class="o">&gt;</span><span class="nt">body</span><span class="p">{</span>
</span><span class='line'>    <span class="k">background-image</span><span class="o">:</span> <span class="sx">url(bg.png)</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个规则对于IE6以及之前老版本是隐藏的。</p>

<h3>明智的使用hack</h3>

<p>使用hack的时候需要谨慎，有时hack会相当复杂，这会使你的CSS文件很长而且很复杂，十分不宜阅读。而且很多hack会有向后兼容的问题，这些hack是针对浏览器是否识别特殊的前缀和属性来实现的，但不能保证之后的浏览器对这些前缀和属性的识别能力。如果确实要使用hack，最好将hack放到统一的样式表中，同时一定要写好注释，便于管理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[float小细节]]></title>
    <link href="http://wibud.github.io/blog/2013/07/08/floatxiao-xi-jie/"/>
    <updated>2013-07-08T10:28:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/07/08/floatxiao-xi-jie</id>
    <content type="html"><![CDATA[<p>之前看了一篇文章，它设置basse.css的时候定义了很多的通用原子类，其中的.fl和.fr类是这样写的：<code>.fl{float:left;display:inline}</code>,<code>.fr{float:right;display:inline}</code></p>

<h3>为什么要在设置了<code>float:left</code>和<code>float:right</code>之外，还要设置<code>display:inline</code>呢？</h3>

<p>其实这是为了解决IE6的双外边距的bug。在IE6中，如果对元素设置了浮动，同时又设置了margin-left或者margin-right的话，margin的值会加倍。解决这个问题的办法就是这是<code>display:inline</code>。所以在设计通用原子类的时候将<code>display:inline</code>引入.fl和.fr类中。</p>

<h3>这样不会影响块级元素吗？</h3>

<p>如果我们对块级元素赋予.fl或.fr类，其中的<code>display:inline</code>不会将块级元素变成行内元素了吗？其实这一点不用担心，<code>float:left</code>，<code>float:right</code>还有<code>position:absolute</code>，会让元素以<code>display:inline-block</code>的方式显示，就算我们设置了<code>display:inline</code>或者<code>display:block</code>，也仍然无效。</p>

<h3>display:inline-block</h3>

<p>disploy的值除了inline和block之外，还有一个十分有用的值：inline-block（IE6,IE7不支持，但是可以实现相同效果）。</p>

<p><code>display:inline-block</code>，从写法上就不难看出，它可肯定是行内元素特性inline和块级元素特性block的结合体，它具有块级元素的特点，可以设置长宽，margin和padding；又具有行内元素的特点，它不独占一行。</p>

<p>那在IE6和IE7下如何实现呢，我们知道IE为盒模型设计了一个专门的属性hasLayout，如果触发行内元素的hasLayout，就能让行内元素拥有块级元素的特性，达到<code>display:inline-block</code>的效果。幸运的是设置<code>display:inline-block</code>，就可以触发hasLayout。当然在IE6和IE7下还是有局限性，我们只能对行内元素实现<code>display:inline-block</code>的效果，对于块级元素就不行了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[监听DOM加载完毕]]></title>
    <link href="http://wibud.github.io/blog/2013/05/31/jian-ting-domjia-zai-wan-bi/"/>
    <updated>2013-05-31T22:06:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/05/31/jian-ting-domjia-zai-wan-bi</id>
    <content type="html"><![CDATA[<p>我们知道javascript是可以在DOM加载完之前就执行的，如果对没有加载的DOM元素进行操作就会导致错误。浏览器的渲染顺序大致如下：</p>

<ul>
<li>解析HTML</li>
<li>下载外部脚本样式</li>
<li>脚本解析执行</li>
<li>DOM完全构建完成</li>
<li>图片等外部资源加载</li>
<li>网页加载完毕</li>
</ul>


<p>那如何判断DOM是否加载完毕呢？使用body的onload事件进行监听？当然可以，但是body的onload是在所有内容，包括图片、flash啊等等内容全部加载后才触发，导致用户需要等待这部分内容加载后才能看到页面的动态内容，才能同页面进行交互，对于追(ti)求(gao)极(bi)致(ge)的程序猿来说，显然是不能接受的了，其实，只要检查如下3点足矣</p>

<ul>
<li>document</li>
<li>document.getElementByTagName和document.getElementById</li>
<li>document.body</li>
</ul>


<p>检查这三点就足够了。接着我们就可以写一个监听DOM何时加载完毕的函数了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">domReady</span><span class="p">(</span><span class="nx">f</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 假如DOM已经加载，马上执行函数</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="nx">domReady</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">f</span><span class="p">();</span>
</span><span class='line'>    <span class="c1">// 如果已经添加了一个函数</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="nx">domReady</span><span class="p">.</span><span class="nx">timer</span><span class="p">){</span>
</span><span class='line'>        <span class="c1">// 把它加入待执行函数清单</span>
</span><span class='line'>        <span class="nx">domReady</span><span class="p">.</span><span class="nx">ready</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>        <span class="c1">// 初始化待执行函数的数组</span>
</span><span class='line'>        <span class="nx">domReady</span><span class="p">.</span><span class="nx">ready</span> <span class="o">=</span> <span class="p">[</span><span class="nx">f</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 尽可能块的检查DOM是否已可用</span>
</span><span class='line'>        <span class="nx">domReady</span><span class="p">.</span><span class="nx">timer</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(</span><span class="nx">isDOMReady</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 检查DOM是否可用</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">isDOMReady</span><span class="p">(){</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 如果我们标记了已可用</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="nx">domReady</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 检查DOM是否可用</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="nb">document</span> <span class="o">&amp;&amp;</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementByTag</span> <span class="o">&amp;&amp;</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span> <span class="o">&amp;&amp;</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 如果可用，停止检查</span>
</span><span class='line'>        <span class="nx">clearInterval</span><span class="p">(</span><span class="nx">domReady</span><span class="p">.</span><span class="nx">timer</span><span class="p">);</span>
</span><span class='line'>        <span class="nx">domReady</span><span class="p">.</span><span class="nx">timer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 执行所有函数</span>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">domReady</span><span class="p">.</span><span class="nx">ready</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>            <span class="nx">domReady</span><span class="p">.</span><span class="nx">ready</span><span class="p">[</span><span class="nx">i</span><span class="p">]();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="nx">domReady</span><span class="p">.</span><span class="nx">ready</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span><span class='line'>        <span class="nx">domReady</span><span class="p">.</span><span class="nx">done</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种方法使用起来很简单，而且不堵塞浏览器的加载。jquery的<code>ready()</code>函数功能使用的就是这种思想，当然实现的更加优雅和完备</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[抛开兼容判断，可靠的DOM事件绑定]]></title>
    <link href="http://wibud.github.io/blog/2013/04/03/pao-kai-jian-rong-pan-duan-,ke-kao-de-domshi-jian-bang-ding/"/>
    <updated>2013-04-03T17:17:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/04/03/pao-kai-jian-rong-pan-duan-,ke-kao-de-domshi-jian-bang-ding</id>
    <content type="html"><![CDATA[<p>最近看到了一个很有意思的添加和删除DOM事件的方法，这个方法十分可靠，只是使用绑定事件的传统方法：<code>element.onclick=function(){...}</code>，但是我们知道，传统的绑定方法有一个很大的弊端，那就是一个元素的一个事件只能绑定一个处理程序，而新的方法很好的解决了这个问题。</p>

<p>让我们先回忆一下一般的我们如何跨浏览器的添加事件？</p>

<p>我想大部分应该都是使用如下的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">eventUtil</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">addEvent</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">ele</span><span class="p">,</span> <span class="nx">handler</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 判断是否支持标准(W3C)事件绑定</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="nx">ele</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">){</span>
</span><span class='line'>            <span class="nx">ele</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// 判断是否是IE事件绑定</span>
</span><span class='line'>        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">ele</span><span class="p">.</span><span class="nx">attachEvent</span><span class="p">){</span>
</span><span class='line'>            <span class="nx">ele</span><span class="p">.</span><span class="nx">attachEvent</span><span class="p">(</span><span class="s2">&quot;on&quot;</span><span class="o">+</span><span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// 传统事件绑定</span>
</span><span class='line'>        <span class="k">else</span><span class="p">{</span>
</span><span class='line'>            <span class="nx">ele</span><span class="p">[</span><span class="s2">&quot;on&quot;</span><span class="o">+</span><span class="nx">type</span><span class="p">]</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过判断是否支持标准事件绑定还是IE事件绑定来决定使用哪种绑定事件的方式。</p>

<p>而新的这个很有意思的事件绑定方式就不同了，下面来看看</p>

<!-- more -->




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">addEvent</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 为每个事件处理函数赋予一个独立的ID</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">handler</span><span class="p">.</span><span class="nx">$$guid</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">handler</span><span class="p">.</span><span class="nx">$$guid</span> <span class="o">=</span> <span class="nx">addEvent</span><span class="p">.</span><span class="nx">guid</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 为元素建立一个事件类型的散列表</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">element</span><span class="p">.</span><span class="nx">events</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">element</span><span class="p">.</span><span class="nx">events</span> <span class="o">=</span> <span class="p">{};</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 为每对元素/事件建立一个事件处理函数的散列表</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">handlers</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">handlers</span><span class="p">){</span>
</span><span class='line'>        <span class="nx">handlers</span> <span class="o">=</span> <span class="nx">element</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 存储已有的事件处理函数(如果已经存在)</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="nx">element</span><span class="p">[</span><span class="s2">&quot;on&quot;</span><span class="o">+</span><span class="nx">type</span><span class="p">]){</span>
</span><span class='line'>            <span class="nx">handlers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">element</span><span class="p">[</span><span class="s2">&quot;on&quot;</span><span class="o">+</span><span class="nx">type</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 在散列表中存储该事件处理函数</span>
</span><span class='line'>    <span class="nx">handlers</span><span class="p">[</span><span class="nx">handler</span><span class="p">.</span><span class="nx">$$guid</span><span class="p">]</span> <span class="o">=</span> <span class="nx">handler</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 赋予一个全局事件处理函数来处理所有工作，使用传统绑定方法</span>
</span><span class='line'>    <span class="nx">element</span><span class="p">[</span><span class="s2">&quot;on&quot;</span><span class="o">+</span><span class="nx">type</span><span class="p">]</span> <span class="o">=</span> <span class="nx">handleEvent</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 创建独立ID的计数器</span>
</span><span class='line'><span class="nx">addEvent</span><span class="p">.</span><span class="nx">guid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">removeEvent</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">// 从列表中删除事件处理函数</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">events</span> <span class="o">&amp;&amp;</span> <span class="nx">element</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">]){</span>
</span><span class='line'>        <span class="k">delete</span> <span class="nx">element</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">][</span><span class="nx">handler</span><span class="p">.</span><span class="nx">$$guid</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">handlerEvent</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">returnValue</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 获取事件对象</span>
</span><span class='line'>    <span class="nx">event</span> <span class="o">=</span> <span class="nx">event</span> <span class="o">||</span> <span class="nx">fixEvent</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">event</span><span class="p">);</span>    <span class="c1">// fixEvent() for IE</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">handlers</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="nx">type</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 依次执行每个事件处理函数</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">handlers</span><span class="p">){</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="nx">$$handlerEvent</span> <span class="o">=</span> <span class="nx">handlers</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">$$handlerEvent</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">===</span> <span class="kc">false</span><span class="p">){</span>
</span><span class='line'>            <span class="nx">returnValue</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="nx">returnValue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 增加一些IE事件对象缺乏的方法</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">fixEvent</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">// 增加W3C标准事件方法</span>
</span><span class='line'>    <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefult</span> <span class="o">=</span> <span class="nx">fixEvent</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">event</span><span class="p">.</span><span class="nx">stopPropagation</span> <span class="o">=</span> <span class="nx">fixEvent</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">evnet</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">fixEvent</span><span class="p">.</span><span class="nx">preventDefault</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">returnValue</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">fixEvent</span><span class="p">.</span><span class="nx">stopPropagation</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">cancelBubble</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span><span class="err">&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>不难看出使用传统的绑定方法可以在所有浏览器中工作，并且可以绑定多个事件处理函数。同时this关键字可以在所有绑定函数中使用，this指向的是当前绑定元素。瞬间逼格上涨，不过对比之前区分IE和标准的绑定方式，代码量的暴增可能也会让追求精简的童鞋抓狂吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JS实现私有成员]]></title>
    <link href="http://wibud.github.io/blog/2013/03/30/jsshi-xian-si-you-cheng-yuan/"/>
    <updated>2013-03-30T12:19:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/03/30/jsshi-xian-si-you-cheng-yuan</id>
    <content type="html"><![CDATA[<p>我们知道JavaScript是面向对象的语言，但是它同其他比如Java不同，它没有私有成员的概念，所有的对象属性都是共有的。不过我们可以通过闭包来实现私有变量。</p>

<h3>私有变量</h3>

<p>定义构造函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">Myobject</span><span class="p">(){</span>
</span><span class='line'>    <span class="c1">// 私有变量</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">privateValue</span> <span class="o">=</span> <span class="s2">&quot;I&#39;m private value&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 私有函数</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">privateFun</span><span class="p">(){</span>
</span><span class='line'>        <span class="k">return</span> <span class="s2">&quot;I&#39;m private function&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 公有方法，可以访问私有成员的特权函数</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">publicFun</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">privateValue</span> <span class="o">+</span> <span class="nx">privateFun</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样`object中的私有成员就对外不可见了，只能通过公共方法进行访问。</p>

<h3>静态私有变量</h3>

<p>之前的私有变量，每个使用构造函数创建的对象都有自己的私有成员，而静态私有变量是要所有的对象共享同一个私有变量，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 静态私有变量</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">staticPrivateValue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 静态私有函数</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">staticPrivateFun</span><span class="p">(){</span>
</span><span class='line'>        <span class="k">return</span> <span class="s2">&quot;I&#39;m static private function&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 构造函数</span>
</span><span class='line'>    <span class="nx">MyObject</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){};</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 公有方法</span>
</span><span class='line'>    <span class="nx">MyObject</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">publicFun</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>        <span class="nx">staticPrivateValue</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">staticPrivateFun</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">})();</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过块级作用域来实现静态私有成员。其中<code>MyObjecct</code>构造函数定义时，没有声明就赋值初始化，导致<code>MyObjecct</code>变成了全局对象，这样在块级作用域外就可以访问到<code>MyObjecct</code>构造函数，而块级作用域中的静态私有变量只有定义的公有方法可以访问，同时对<code>MyObjecct</code>所有对象都是共享的。</p>

<!-- more -->


<h3>单例</h3>

<p>单例即是只能创建一个实例对象，不需要构造函数，直接返回一个对象即可实现单例。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">singleObj</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 私有成员</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">privateValue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">privateFun</span><span class="p">(){</span>
</span><span class='line'>        <span class="k">return</span> <span class="s2">&quot;Hello&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 返回对象</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 公用方法</span>
</span><span class='line'>        <span class="nx">publicFun</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>            <span class="nx">privateValue</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">privateFun</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}();</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过使用一个返回对象的匿名函数来实现单例模式和私有成员。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript作用域与闭包]]></title>
    <link href="http://wibud.github.io/blog/2013/03/28/javascriptzuo-yong-yu-yu-bi-bao/"/>
    <updated>2013-03-28T20:11:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/03/28/javascriptzuo-yong-yu-yu-bi-bao</id>
    <content type="html"><![CDATA[<p>在读《JavaScript权威指南》和《JavaScript高级程序设计》的时候感觉俩本书对JS的作用域讲的都不太清晰，于是就自己总结了一下。</p>

<h3>执行环境和作用域</h3>

<p>执行环境就是JS代码执行时所在的环境，每个执行环境都有一个与之关联的<strong>变量对象</strong>，这个对象中就保存着执行环境中的<strong>所有变量和函数</strong>。全局执行环境是最外围的执行环境，也就是window对象了，所以我们定义的全局变量和函数都保存在window对象中。</p>

<p>对于函数来说，每个函数都有一个自己执行环境。</p>

<p>当代码在环境中执行时，会创建一个作用域链，其实就是代码所在的一个个执行环境（嵌套的）的变量对象（函数除外，之后讨论）做成的链，链的最前面当然是变量直接所在的执行环境的变量对象，之后依次是嵌套包含的上级执行环境的变量对象，全局执行环境的变量对象位于链的末尾。使用一个变量时就会从变量的作用域链头部开始往后查找直到找到这个变量。</p>

<p>而<strong>函数</strong>就有些特殊了，函数是通过词法来划分作用域的，在函数定义时，它的作用域链就保存了起来，而并不是执行函数的时候创建的作用域链，这也就是为什么会有闭包这个现象了。函数的作用域链中的变量对象是函数的调用对象（活动对象），调用对象中保存有函数的参数，函数中定义的局部变量。这里注意的是this是一个关键字，并不是调用对象的一个属性，this和arguments都是在函数<strong>执行时</strong>，调用对象取得的，this代表的就是函数据以执行的执行环境</p>

<h3>闭包</h3>

<p>闭包的<strong>定义</strong>：有权访问另一个函数作用域中的变量的函数。简单讲就是在一个函数内部又创建了一个函数。下面讲讲闭包需要注意的问题：</p>

<h4>1. 内存泄漏</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">outer</span><span class="p">(</span><span class="nx">param</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">param</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 创建函数</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">inner</span> <span class="o">=</span> <span class="nx">outer</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 调用函数</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">inner</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面就是一个简单的闭包的例子，正常来看是没什么问题，<code>outer()</code>函数返回后它的作用域链会被销毁，但是它内部的匿名函数的作用域链依然引用<code>outer()</code>函数的调用对象，致使<code>outer()</code>函数的调用对象依然留在内存中。所以我们需要解除对匿名函数的引用。</p>

<pre><code>// 解除对匿名函数的引用，以便释放内存
inner = null;
</code></pre>

<!-- more -->


<p>再看下面这个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">handler</span><span class="p">(){</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">ele</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;someone&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">ele</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>        <span class="nx">alert</span><span class="p">(</span><span class="nx">ele</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果闭包的作用域链中保存着一个HTML元素，那么将使得该元素无法被销毁。上面的例子创建了一个元素的<code>onclick</code>事件的处理程序的闭包，由于匿名函数一直保持着<code>handler()</code>函数的调用对象，使得只要匿名函数存在，对于HTMl element元素的引用就至少为1,而它所占用的内存也就一直得不到回收。这就需要我们手动显示的收回引用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">handler</span><span class="p">(){</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">ele</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;someone&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">ele</span><span class="p">.</span><span class="nx">id</span>
</span><span class='line'>    <span class="nx">ele</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>        <span class="nx">alert</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">ele</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>2. this对象问题</h4>

<blockquote><p>匿名函数的执行环境具有全局性，因此this对象通常指向window</p></blockquote>

<p>在闭包中使用this对象可能也会导致问题。看下面的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s2">&quot;window&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">name</span> <span class="o">:</span> <span class="s2">&quot;object&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">getName</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>        <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">object</span><span class="p">.</span><span class="nx">getName</span><span class="p">()());</span>      <span class="c1">// &quot;window&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>会alert出&#8221;window&#8221;，是不是感觉很奇怪？</p>

<p>上面提到过，this对象是函数被调用时，调用对象取得的，内部函数在沿着作用域链搜素this的值的时候，首先就会搜索到它自己的调用对象，就可以找到this变量了，这样根本就不可能访问外部函数的this变量。解决这个问题很简单，只要将this对象保存到闭包访问的到的变量里就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s2">&quot;window&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">name</span> <span class="o">:</span> <span class="s2">&quot;object&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">getName</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">thit</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建octopress遇到的坑]]></title>
    <link href="http://wibud.github.io/blog/2013/02/23/da-jian-octopressyu-dao-de-keng/"/>
    <updated>2013-02-23T20:16:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/02/23/da-jian-octopressyu-dao-de-keng</id>
    <content type="html"><![CDATA[<p>如何使用octopress搭建博客这里就不赘述了，最权威的还是去看<a href="http://octopress.org/docs/">官网教程</a>好了，十分的详尽。国人翻译的教程也海了去了，用某度一搜就好了。</p>

<p>尝鲜使用octopress搭建博客，过程一波三折，遇到了一个十分奇葩的问题，纠结了很久。</p>

<p>在我的ubuntu系统上将环境搭建好以后,执行<code>rake generate</code>时，出现了如下的问题。</p>

<pre><code>## Generating Site with Jekyll
overwrite source/stylesheets/screen.css
Configuration from /Users/foobar/Development/project/foobar.github.com/_config.yml
Building site: source -&gt; public
Liquid Exception: undefined method `gsub' for nil:NilClass in page
/Users/foobar/Development/project/foobar.github.com/plugins/octopress_filters.rb:123:in `shorthand_url'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/context.rb:58:in `invoke'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/variable.rb:43:in `block in render'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/variable.rb:38:in `each'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/variable.rb:38:in `inject'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/variable.rb:38:in `render'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/block.rb:94:in `block in render_all'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/block.rb:92:in `collect'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/block.rb:92:in `render_all'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/tags/if.rb:39:in `block (2 levels) in render'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/tags/if.rb:37:in `each'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/tags/if.rb:37:in `block in render'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/context.rb:91:in `stack'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/tags/if.rb:36:in `render'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/block.rb:94:in `block in render_all'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/block.rb:92:in `collect'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/block.rb:92:in `render_all'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/block.rb:82:in `render'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/template.rb:124:in `render'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/jekyll-0.12.0/lib/jekyll/tags/include.rb:26:in `block (2 levels) in render'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/context.rb:91:in `stack'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/jekyll-0.12.0/lib/jekyll/tags/include.rb:25:in `block in render'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/jekyll-0.12.0/lib/jekyll/tags/include.rb:20:in `chdir'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/jekyll-0.12.0/lib/jekyll/tags/include.rb:20:in `render'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/block.rb:94:in `block in render_all'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/block.rb:92:in `collect'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/block.rb:92:in `render_all'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/block.rb:82:in `render'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/template.rb:124:in `render'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/liquid-2.3.0/lib/liquid/template.rb:132:in `render!'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/jekyll-0.12.0/lib/jekyll/convertible.rb:101:in `do_layout'
/Users/foobar/Development/project/foobar.github.com/plugins/post_filters.rb:167:in `do_layout'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/jekyll-0.12.0/lib/jekyll/page.rb:100:in `render'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/jekyll-0.12.0/lib/jekyll/site.rb:204:in `block in render'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/jekyll-0.12.0/lib/jekyll/site.rb:203:in `each'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/jekyll-0.12.0/lib/jekyll/site.rb:203:in `render'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/jekyll-0.12.0/lib/jekyll/site.rb:41:in `process'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/gems/jekyll-0.12.0/bin/jekyll:264:in `&lt;top (required)&gt;'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/bin/jekyll:19:in `load'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/bin/jekyll:19:in `&lt;main&gt;'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/bin/ruby_noexec_wrapper:14:in `eval'
/Users/foobar/.rvm/gems/ruby-1.9.3-p392/bin/ruby_noexec_wrapper:14:in `&lt;main&gt;'
Build Failed
</code></pre>

<p>查了半天原因，才发现只是因为<code>_config.yml</code>文件中的<code>url:</code>没有赋值，很奇怪，在<code>rake setup_github_pages</code>时有提示你输入Repo地址，但是却没有写入这个配置文件中。之后自己写上就安了~~</p>
]]></content>
  </entry>
  
</feed>
