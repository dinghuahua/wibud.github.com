
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>[译]GPU Accelerated Compositing in Chrome（GPU合成加速） - Winter Bud</title>
	<meta name="author" content="wibud">

	
	<meta name="description" content="[译]GPU Accelerated Compositing in Chrome（GPU合成加速） 原文地址：http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome 作者： &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Winter Bud" type="application/atom+xml">
	
	<link rel="canonical" href="http://wibud.github.io/blog/2014/11/03/yi-gpu-accelerated-compositing-in-chrome(gpuhe-cheng-jia-su-)/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="/javascripts/libs/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("wi_bud@163.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>

<nav id="main-nav">
<section class="aboutme">
  <i>Winter Bud</i>
  <p>
    UED程序猿；专业前端，业余JAVA；爱鼓捣、瞎折腾；讲的了段子，写的了代码
  </p>
</section>

<ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="/about">About</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:wi_bud@163.com" title="Email">Email</a>
		
		
		
		
		
			<a class="github" href="https://github.com/wibud" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
		
			<a class="weibo" href="http://weibo.com/u/2435540027" title="weibo">Weibo</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">[译]GPU Accelerated Compositing in Chrome（GPU合成加速）</h1>
	<div class="entry-content" itemprop="articleBody"><blockquote><p>原文地址：<a href="http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome">http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome</a></p>

<p>作者：Tom Wiltzius, Vangelis Kokkevis &amp; the Chrome Graphics team</p></blockquote>

<h3>摘要</h3>

<p>本文讲述了chrome中硬件加速合成（compositing[1]）的实现</p>

<h3>简介：为什么使用硬件进行合成（compositing）</h3>

<p>传统方式下，浏览器依赖CPU来渲染页面内容。随着GPU硬件能力的不断发展（包括一些超小型设备的硬件能力也有很大提升），人们开始试图使用GPU硬件能力来获得更好的性能和更少的电量消耗。使用GPU来渲染合成页面内容可以获得明显的速度的提升。</p>

<p>硬件合成有以下几个优点：</p>

<ul>
<li><p>GPU在合成页面层（layer）上的效率要比CPU高很多，尤其是涉及大量像素的drawing[2]和compositing操作。当然，GPU设计出来本来就是做这些工作的。</p></li>
<li><p>Expensive readbacks aren&rsquo;t necessary for content already on the GPU (such as accelerated video, Canvas2D, or WebGL).</p></li>
<li><p>Parallelism between the CPU and GPU, which can operate at the same time to create an efficient graphics pipeline.</p></li>
</ul>


<h2>Part 1：Blink Rending 基础</h2>

<p>Blink Rending 引擎（由Google和Opera Software开发的浏览器排版引擎）的源码十分繁多和复杂。为更好理解在chrome中GPU加速是如何工作的，我们首先需要了解Blink引擎是如何渲染页面的。</p>

<h3>Nodes和DOM树</h3>

<p>在Blink引擎中，页面内容是存储为由Node对象组成的树状结构，成为DOM树。每一个HTML element元素都有一个Node对象与之对应，DOM树的根节点永远都是Document Node。</p>

<h3>从Nodes到RenderObjects</h3>

<p>DOM树种每个node节点都有一个对应的RenderObject。RenderObject存储在与DOM树相对应的树形结构中——Render数（Render Tree）。RenderObject知道如何在屏幕上paint[3] Node内容，当然为实现这一操作，RenderObject会调用GraphicsContext来执行必要的draw[2]操作。其中，GraphicsContext就是负责将像素写入位图（bitmap）[4]中，这些位图最终会展示在屏幕上。</p>

<p>在老的实现方式下，大部分GraphicsContext调用会去调用一个SkCanvas或者SkPlatformCanvas等等，将其paint进一个软件位图（software bitmap）中（参考<a href="http://www.chromium.org/developers/design-documents/graphics-and-skia">这篇文章</a>了解更多细节）。但是，现在painting不在放在主线程（main thread）（本文之后会讲到），这些命令现在会记录到一个SkPicture中。SkPicture是一个序列化的数据结构，它可以捕获命令并在之后重发这些命令，类似一个<a href="http://en.wikipedia.org/wiki/Display_list">display list</a></p>

<h3>从RenderObjects到RenderLayers</h3>

<p>每一个RenderObject都直接或间接（通过其父对象）的同一个RenderLayer相关联。</p>

<p>一般来说，拥有相同的坐标空间（比如：受相同CSS transform影响的）的RenderObjects，属于同一个RenderLayer。RenderLayer的作用就是保证页面元素以正确的顺序合成（composited），这样才能正确的展示元素的重叠以及半透明元素等等。会有一些情形，为一些特殊的RenderObjects创建一个新的RenderLayer。一下是常见的一定会新建RenderLayer的RenderObject：</p>

<ul>
<li>页面的根节点的RenderObject</li>
<li>有明确的CSS定位属性（relative，absolute或者transform）</li>
<li>是透明的</li>
<li>有CSS overflow、CSS alpha遮罩（alpha mash）或者CSS reflection</li>
<li>有CSS 滤镜（fliter）</li>
<li>3D环境或者2D加速环境的canvas元素对应的RenderObject</li>
<li>video元素对应的RenderObject</li>
</ul>


<p>值得注意的是，RenderObject同RenderLayer并不是一对一的。对于上述特殊的RenderObjects，它对应于为它所创建的心得RenderLayer，而其他的RenderObjects，对应于其第一个拥有RenderLayer的父RenderObject</p>

<p>RenderLayer也是一个树状的体系。根节点就是页面根元素所对应的RenderLayer，视觉上，每一个layer节点的后代都包含在父layer中。每一个RenderLayer的子layer保存在两个升序排列的列表中，分别是negZOrderList（负z-index的layers，即当前layer之下的layer）和posZOrderList（正z-index的layers，即当前layer之上的layer）</p>

<!-- more -->


<h3>从RenderLayers到GraphicsLayers</h3>

<p>为利用合成器（compositor），一些（不是全部）RenderLayers有独立的背景（backing surface）（有独立背景的层layer被认为是合成层（compositing layers））。如果RenderLayer是一个合成层，那么它又属于它自己的单独的GraphicsLayer，否则它和它的第一个拥有GraphicsLayer的父layer共用一个GraphicsLayer。如同RenderObject同Renderlayer的关系一样。</p>

<p>每一个GraphicsLayer都有一个GraphicsContext，其对应的RenderLayer会paint进GraphicsContext中。合成器（compositor）最终会负责，将由GraphicsContext输出的位图（bitmap[4]）合并成最终屏幕显示的图片。</p>

<p>虽然，在理论上，每一个独立的RenderLayer都可以paint进一个独立的背景中（拥有自己独立的背景，成为独立的合成层），但是，实际上，这样做十分消耗显存。在当前的Blink引擎的实现中，只有在如下的场景中，RenderLayer会是独立的合成层：</p>

<ul>
<li>有3D或者透视变换的CSS属性的层</li>
<li>使用加速视频解码的video元素的层</li>
<li>3D或者加速2D环境下的canvas元素的层</li>
<li>插件，比如flash（Layer is used for a composited plugin）</li>
<li>对opacity和transform应用了CSS动画的层</li>
<li>使用了加速CSS滤镜（filters）的层</li>
<li>有合成层后代的层</li>
<li>同合成层重叠，且在该合成层上面（z-index）渲染的层</li>
</ul>


<h3>层压缩（Layer Squashing）</h3>

<p>所有的规则都会有漏洞。正如上面提到的，GraphicsLayers会消耗内存和其他资源（比如一些饱受争议的操作，随着GraphicsLayer树的大小增长，会使CPU执行时间越来越长）。当一些RenderLayer同一个有着独立背景的RenderLayer重叠时，就会产生大量的额外的层，十分消耗资源。</p>

<p>我们把产生合成层的自身原因（比如有3D变换的层）称之为直接原因（direct compositing reasons）。为了防止上述所说的“层爆炸”，当很多元素在因直接原因产生的层之上时，Blink引擎，会将这些RenderLayers覆盖在“direct compositing reason”的RenderLayer上，同时将他们压缩（squash）成单一的一个备份。这就防止了由覆盖引起的层爆炸。更多细节请看<a href="https://docs.google.com/presentation/d/1WOhbWLkhMyo4vZUaHq-FO-mt0B2sejXw-lMwohD5iUo/edit#slide=id.g2a8a2080a_088">这里</a>和<a href="https://docs.google.com/a/chromium.org/presentation/d/1dDE5u76ZBIKmsqkWi2apx3BqV8HOcNf4xxBdyNywZR8/edit#slide=id.p">这里</a></p>

<h3>从GraphicsLayers到WebLayers到CC Layers</h3>

<p>chrome在 src/webkit/renderer/compositor_bindings中实现了Web*Layer的接口</p>

<h3>The compositing Forest</h3>

<p>总的来说，为rendering服务的有如下四种树形结构：</p>

<ul>
<li>DOM Tree，基本的模型</li>
<li>RenderObject Tree，同DOM树的可见节点是一一对应的。RenderObject知道如何去paint其相对应的DOM节点</li>
<li>RenderLayer Tree，由RenderLayers组成，这些RenderLayer对应于RenderObject树的RenderObject。这种对应关系是一对多的。</li>
<li>GraphicsLayer Tree，由GraphicsLayers组成，这些GraphicsLayer对应于RenderLayer树的RenderLayer。这种对应关系是一对多的。</li>
</ul>


<p>如下图所示：</p>

<p><img src="/images/private/The-Compositing-Forest.png" alt="" /></p>

<p>之后文章中所说的层（layer）都代指cc layer（chrome compositor layer）</p>

<h2>Part 2：The Compositor（合成器）</h2>

<p>未完待续</p>

<h2>附录C 术语表</h2>

<p>[1] compositing：将RenderLayer的纹理（texture）合成为最终屏幕上的图片</p>

<p>[2] drawing：rendering术语，将像素点绘制到屏幕上</p>

<p>[3] painting：rendering术语，RenderObjects调用GraphicsContext API生成相应的视觉展现。生成元素呈现的像素，例如，一个有着灰色背景，有文字的元素，当浏览器paint它时，是决定哪些像素填充背景，哪些像素填充文字，然后浏览器将这些像素存入位图（bitmap）中。</p>

<p>[4] bitmap：内存或显存中一组像素值</p>

<p>[5] texture：应用于GPU 3D模型上的位图（bitmap）</p>
</div>

</article>

	<div class="share">
	
	
	
	<a class="addthis_counter addthis_pill_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid="></script>
</div>




  <section>
    <h1>Comments</h1>
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread" data-title="[译]GPU Accelerated Compositing in Chrome（GPU合成加速）"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"wibud"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END -->
</div>
  </section>

</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    wibud


<!-- Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a> &#8211;>
</footer>
		</div>
	</div>
	






<!-- 
 -->


</body>
</html>
