<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 前端 | Winter Bud]]></title>
  <link href="http://wibud.github.io/blog/categories/qian-duan/atom.xml" rel="self"/>
  <link href="http://wibud.github.io/"/>
  <updated>2014-11-03T00:21:38+08:00</updated>
  <id>http://wibud.github.io/</id>
  <author>
    <name><![CDATA[wibud]]></name>
    <email><![CDATA[wi_bud@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[译]GPU Accelerated Compositing in Chrome（GPU合成加速）]]></title>
    <link href="http://wibud.github.io/blog/2014/11/03/yi-gpu-accelerated-compositing-in-chrome(gpuhe-cheng-jia-su-)/"/>
    <updated>2014-11-03T00:10:52+08:00</updated>
    <id>http://wibud.github.io/blog/2014/11/03/yi-gpu-accelerated-compositing-in-chrome(gpuhe-cheng-jia-su-)</id>
    <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome">http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome</a></p>

<p>作者：Tom Wiltzius, Vangelis Kokkevis &amp; the Chrome Graphics team</p></blockquote>

<h3>摘要</h3>

<p>本文讲述了chrome中硬件加速合成（compositing[1]）的实现</p>

<h3>简介：为什么使用硬件进行合成（compositing）</h3>

<p>传统方式下，浏览器依赖CPU来渲染页面内容。随着GPU硬件能力的不断发展（包括一些超小型设备的硬件能力也有很大提升），人们开始试图使用GPU硬件能力来获得更好的性能和更少的电量消耗。使用GPU来渲染合成页面内容可以获得明显的速度的提升。</p>

<p>硬件合成有以下几个优点：</p>

<ul>
<li><p>GPU在合成页面层（layer）上的效率要比CPU高很多，尤其是涉及大量像素的drawing[2]和compositing操作。当然，GPU设计出来本来就是做这些工作的。</p></li>
<li><p>Expensive readbacks aren&rsquo;t necessary for content already on the GPU (such as accelerated video, Canvas2D, or WebGL).</p></li>
<li><p>Parallelism between the CPU and GPU, which can operate at the same time to create an efficient graphics pipeline.</p></li>
</ul>


<h2>Part 1：Blink Rending 基础</h2>

<p>Blink Rending 引擎（由Google和Opera Software开发的浏览器排版引擎）的源码十分繁多和复杂。为更好理解在chrome中GPU加速是如何工作的，我们首先需要了解Blink引擎是如何渲染页面的。</p>

<h3>Nodes和DOM树</h3>

<p>在Blink引擎中，页面内容是存储为由Node对象组成的树状结构，成为DOM树。每一个HTML element元素都有一个Node对象与之对应，DOM树的根节点永远都是Document Node。</p>

<h3>从Nodes到RenderObjects</h3>

<p>DOM树种每个node节点都有一个对应的RenderObject。RenderObject存储在与DOM树相对应的树形结构中——Render数（Render Tree）。RenderObject知道如何在屏幕上paint[3] Node内容，当然为实现这一操作，RenderObject会调用GraphicsContext来执行必要的draw[2]操作。其中，GraphicsContext就是负责将像素写入位图（bitmap）[4]中，这些位图最终会展示在屏幕上。</p>

<p>在老的实现方式下，大部分GraphicsContext调用会去调用一个SkCanvas或者SkPlatformCanvas等等，将其paint进一个软件位图（software bitmap）中（参考<a href="http://www.chromium.org/developers/design-documents/graphics-and-skia">这篇文章</a>了解更多细节）。但是，现在painting不在放在主线程（main thread）（本文之后会讲到），这些命令现在会记录到一个SkPicture中。SkPicture是一个序列化的数据结构，它可以捕获命令并在之后重发这些命令，类似一个<a href="http://en.wikipedia.org/wiki/Display_list">display list</a></p>

<h3>从RenderObjects到RenderLayers</h3>

<p>每一个RenderObject都直接或间接（通过其父对象）的同一个RenderLayer相关联。</p>

<p>一般来说，拥有相同的坐标空间（比如：受相同CSS transform影响的）的RenderObjects，属于同一个RenderLayer。RenderLayer的作用就是保证页面元素以正确的顺序合成（composited），这样才能正确的展示元素的重叠以及半透明元素等等。会有一些情形，为一些特殊的RenderObjects创建一个新的RenderLayer。一下是常见的一定会新建RenderLayer的RenderObject：</p>

<ul>
<li>页面的根节点的RenderObject</li>
<li>有明确的CSS定位属性（relative，absolute或者transform）</li>
<li>是透明的</li>
<li>有CSS overflow、CSS alpha遮罩（alpha mash）或者CSS reflection</li>
<li>有CSS 滤镜（fliter）</li>
<li>3D环境或者2D加速环境的canvas元素对应的RenderObject</li>
<li>video元素对应的RenderObject</li>
</ul>


<p>值得注意的是，RenderObject同RenderLayer并不是一对一的。对于上述特殊的RenderObjects，它对应于为它所创建的心得RenderLayer，而其他的RenderObjects，对应于其第一个拥有RenderLayer的父RenderObject</p>

<p>RenderLayer也是一个树状的体系。根节点就是页面根元素所对应的RenderLayer，视觉上，每一个layer节点的后代都包含在父layer中。每一个RenderLayer的子layer保存在两个升序排列的列表中，分别是negZOrderList（负z-index的layers，即当前layer之下的layer）和posZOrderList（正z-index的layers，即当前layer之上的layer）</p>

<!-- more -->


<h3>从RenderLayers到GraphicsLayers</h3>

<p>为利用合成器（compositor），一些（不是全部）RenderLayers有独立的背景（backing surface）（有独立背景的层layer被认为是合成层（compositing layers））。如果RenderLayer是一个合成层，那么它又属于它自己的单独的GraphicsLayer，否则它和它的第一个拥有GraphicsLayer的父layer共用一个GraphicsLayer。如同RenderObject同Renderlayer的关系一样。</p>

<p>每一个GraphicsLayer都有一个GraphicsContext，其对应的RenderLayer会paint进GraphicsContext中。合成器（compositor）最终会负责，将由GraphicsContext输出的位图（bitmap[4]）合并成最终屏幕显示的图片。</p>

<p>虽然，在理论上，每一个独立的RenderLayer都可以paint进一个独立的背景中（拥有自己独立的背景，成为独立的合成层），但是，实际上，这样做十分消耗显存。在当前的Blink引擎的实现中，只有在如下的场景中，RenderLayer会是独立的合成层：</p>

<ul>
<li>有3D或者透视变换的CSS属性的层</li>
<li>使用加速视频解码的video元素的层</li>
<li>3D或者加速2D环境下的canvas元素的层</li>
<li>插件，比如flash（Layer is used for a composited plugin）</li>
<li>对opacity和transform应用了CSS动画的层</li>
<li>使用了加速CSS滤镜（filters）的层</li>
<li>有合成层后代的层</li>
<li>同合成层重叠，且在该合成层上面（z-index）渲染的层</li>
</ul>


<h3>层压缩（Layer Squashing）</h3>

<p>所有的规则都会有漏洞。正如上面提到的，GraphicsLayers会消耗内存和其他资源（比如一些饱受争议的操作，随着GraphicsLayer树的大小增长，会使CPU执行时间越来越长）。当一些RenderLayer同一个有着独立背景的RenderLayer重叠时，就会产生大量的额外的层，十分消耗资源。</p>

<p>我们把产生合成层的自身原因（比如有3D变换的层）称之为直接原因（direct compositing reasons）。为了防止上述所说的“层爆炸”，当很多元素在因直接原因产生的层之上时，Blink引擎，会将这些RenderLayers覆盖在“direct compositing reason”的RenderLayer上，同时将他们压缩（squash）成单一的一个备份。这就防止了由覆盖引起的层爆炸。更多细节请看<a href="https://docs.google.com/presentation/d/1WOhbWLkhMyo4vZUaHq-FO-mt0B2sejXw-lMwohD5iUo/edit#slide=id.g2a8a2080a_088">这里</a>和<a href="https://docs.google.com/a/chromium.org/presentation/d/1dDE5u76ZBIKmsqkWi2apx3BqV8HOcNf4xxBdyNywZR8/edit#slide=id.p">这里</a></p>

<h3>从GraphicsLayers到WebLayers到CC Layers</h3>

<p>chrome在 src/webkit/renderer/compositor_bindings中实现了Web*Layer的接口</p>

<h3>The compositing Forest</h3>

<p>总的来说，为rendering服务的有如下四种树形结构：</p>

<ul>
<li>DOM Tree，基本的模型</li>
<li>RenderObject Tree，同DOM树的可见节点是一一对应的。RenderObject知道如何去paint其相对应的DOM节点</li>
<li>RenderLayer Tree，由RenderLayers组成，这些RenderLayer对应于RenderObject树的RenderObject。这种对应关系是一对多的。</li>
<li>GraphicsLayer Tree，由GraphicsLayers组成，这些GraphicsLayer对应于RenderLayer树的RenderLayer。这种对应关系是一对多的。</li>
</ul>


<p>如下图所示：</p>

<p><img src="/images/private/The-Compositing-Forest.png" alt="" /></p>

<p>之后文章中所说的层（layer）都代指cc layer（chrome compositor layer）</p>

<h2>Part 2：The Compositor（合成器）</h2>

<p>未完待续</p>

<h2>附录C 术语表</h2>

<p>[1] compositing：将RenderLayer的纹理（texture）合成为最终屏幕上的图片</p>

<p>[2] drawing：rendering术语，将像素点绘制到屏幕上</p>

<p>[3] painting：rendering术语，RenderObjects调用GraphicsContext API生成相应的视觉展现。生成元素呈现的像素，例如，一个有着灰色背景，有文字的元素，当浏览器paint它时，是决定哪些像素填充背景，哪些像素填充文字，然后浏览器将这些像素存入位图（bitmap）中。</p>

<p>[4] bitmap：内存或显存中一组像素值</p>

<p>[5] texture：应用于GPU 3D模型上的位图（bitmap）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript严格模式详解]]></title>
    <link href="http://wibud.github.io/blog/2014/01/09/javascriptyan-ge-mo-shi-xiang-jie/"/>
    <updated>2014-01-09T15:17:48+08:00</updated>
    <id>http://wibud.github.io/blog/2014/01/09/javascriptyan-ge-mo-shi-xiang-jie</id>
    <content type="html"><![CDATA[<h2>一、简介</h2>

<p>严格模式（strict mode）是在ES5（ECMAScript 5）中引入的一种新的JavaScript运行模式，该模式下，禁止了很多JavaScript中问题较多、容易出错、影响应能的特性，目的是让JavaScript在更为严格的条件下运行，减少怪异行为和语言不合理的地方，提高编译运行性能（比如禁用with语句），增强了代码本身的安全性。</p>

<p>在ES5之前的版本是不支持严格模式的，但是严格模式有很好的向后兼容性，因为低版本标准的引擎会忽略严格模式的声明，这个会在之后进行介绍。</p>

<p>想了解各浏览器对于严格模式的支持情况戳这里<a href="http://kangax.github.io/es5-compat-table/">ECMAScript 5 compatibility table</a>，其中还统计了ES5新增特性的兼容情况。</p>

<h2>二、声明</h2>

<p>声明调用严格模式十分简单，也有些怪异，使用字符串字面量：</p>

<pre><code class="javascript">    "use strict";
</code></pre>

<p>之所以使用字符串字面量好处就是可以向后兼容，对于不支持严格模式的引擎，执行这条语句没有任何作用和影响。当然，如果我们使用了严格模式，那么就需要使用支持严格模式的引擎进行测试，使用低版本的引擎无法检测出严格模式下的错误。</p>

<p>声明方式有如下两种：</p>

<ul>
<li>1、声明整个脚本</li>
</ul>


<p>将<code>"use strict;"</code>在脚本文件第一行，且必须是第一行，否则严格模式将无效。</p>

<blockquote><p>在<code>"use strict;"</code>前不能有任何执行语句，即使是一个空的分号，都会使严格模式失效。</p></blockquote>

<p><code>&lt;script&gt;</code>包含的脚本块和引入的外部文件对于严格模式来说都是相互独立的，也就是说，一个脚本块或脚本文件设置成严格模式执行，并不会影响到其他的脚本块和脚本文件。</p>

<pre><code class="javascript">    &lt;script&gt;
        "use strict";
        console.log("严格模式");
    &lt;/script&gt;
    &lt;script&gt;
        console.log("正常模式");
    &lt;/script&gt;
</code></pre>

<ul>
<li>2、声明单个函数体</li>
</ul>


<p>单个函数的声明和整个脚本的类似，需要将<code>"use strict;"</code>放在函数体的第一行。这样该函数就会以严格模式运行。</p>

<pre><code class="javascript">    function f(){
        "use strict";
        // ...
    }
</code></pre>

<!-- more -->


<p>在大型多人合作的项目中使用严格模式，就需要多加注意了。因为，在开发中可能使用了多个脚本文件，而在部署时，会将多个文件合并成一个，如果有的脚本文件使用严格模式，而有的并没有使用，那么合并起来就可能导致意想不到的问题。比如，需要使用严格模式的地方失效了，而不需要使用严格模式的地方反而运行在严格模式下了。</p>

<p>对于此类问题，有如下两种的解决方法：</p>

<ul>
<li>1、不将严格模式运行的文件和正常模式运行的文件合并起来。</li>
</ul>


<p>这应该是最简单的解决方法了，那么你在部署的时候就至少需要两个独立的脚本文件。但这样无疑会对你的文件管理增加负担。</p>

<ul>
<li>2、使用独立作用域（立即调用的函数表达式）</li>
</ul>


<p>将脚本文件内容包含再立即调用的函数表达式中，就好像模块一样。</p>

<pre><code class="javascript">    (function(){
        "use strict";
        function f(){
            // ...
        };
        // ...
    })();
</code></pre>

<p>这样合并成一个文件以后就不会相互影响了</p>

<h2>三、严格模式的限制</h2>

<p>以下列出了严格模式最主要的限制。</p>

<ul>
<li>1、变量必须使用var声明</li>
</ul>


<p>正常模式下，未声明的变量，默认是全局变量，而在严格模式下，必须对变量进行声明，否则会报错：“SCRIPT5042：严格模式下未定义变量”。</p>

<pre><code class="javascript">    "use strict";
    testValue = 1;  // 报错
    for(i=0; i&lt;10; i++){    // 报错
        // ...
    }
</code></pre>

<ul>
<li>2、禁止写入只读属性</li>
</ul>


<p>正常模式下，对对象的只读属性进行赋值，不会出现错误，只是会默认失效，而在严格模式下，写入只读属性（包括使用get进行读取的属性）会报错：“SCRIPT5045：严格模式下不允许分配到只读属性”。</p>

<pre><code class="javascript">    "use strict";
    var testObj = Object.defineProperties({}, {
        prop1: {
            value: 10,
            writable: false // by default
        },
        prop2: {
            get: function () {}
        }
    });
    testObj.prop1 = 20;     // 报错
    testObj.prop2 = 30;     // 报错
</code></pre>

<ul>
<li>3、禁止为不可扩展的对象新增属性</li>
</ul>


<p>正常模式下，为不可扩展的对象添加属性不会报错，只会默认失效，而在严格模式下，会报错：“SCRIPT5046：无法为不可扩展的对象创建属性”。</p>

<pre><code class="javascript">    "use strict";
    var testObj = new Object();
    Object.preventExtensions(testObj);
    testObj.name = "Bob";   // 报错
</code></pre>

<ul>
<li>4、禁止删除变量、函数、参数和configurable为false的属性</li>
</ul>


<p>在严格模式下，只有configurable特性设置为true的对象属性才可以被删除，否则将报错：“SCRIPT1045：严格模式下不允许对 &lt;表达式> 调用 Delete”。</p>

<pre><code class="javascript">    "use strict";
    var testvar = 15;
    function testFunc() {};
    delete testvar;     // 报错
    delete testFunc;    // 报错

    Object.defineProperty(testObj, "testvar", {
        value: 10,
        configurable: false
    });
    delete testObj.testvar;     // 报错
</code></pre>

<ul>
<li>5、禁止对象属性名重复</li>
</ul>


<p>正常模式下，如果对象的属性名重复，那么后一个属性的值会覆盖前一个同名属性的值，而在严格模式下，如果对象有同名属性，则会报错：“SCRIPT1046：严格模式下不允许一个属性有多个定义”。</p>

<pre><code class="javascript">    "use strict";
    var testObj = {
        prop1: 10,
        prop2: 15,
        prop1: 20
    };  // 报错
</code></pre>

<ul>
<li>6、禁止函数参数名重复</li>
</ul>


<p>正常模式下，如果函数有多个重名参数，则可以使用argument[i]来读取相应的参数，而在严格模式下，如果函数存在参数重名，则会报错：“SCRIPT1038：严格模式下不允许正式参数名称重复”。</p>

<pre><code class="javascript">    "use strict";
    function testFunc(param1, param1) {
        return;
    };  // 报错
</code></pre>

<ul>
<li>7、保留关键字</li>
</ul>


<p>为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。</p>

<p>在严格模式下，使用这些这些保留字做变脸或函数名都会报错：“SCRIPT1050：无法使用标识符的未来保留字。 严格模式下将保留标识符名称。”</p>

<blockquote><p>此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。</p></blockquote>

<ul>
<li>8、禁止八进制数值</li>
</ul>


<p>正常模式下，整数数值的第一位如果是0，表示是八进制数，而在严格模式下，禁止对数值文本分配八进制值，或尝试对八进制值使用转义，否则报错：“SCRIPT1039：严格模式下不允许使用八进制数字参数和转义字符”。</p>

<pre><code class="javascript">    "use strict";
    var testoctal = 010;    // 报错
    var testescape = \010;  // 报错
</code></pre>

<ul>
<li>9、禁止this指向全局对象</li>
</ul>


<p>在严格模式下，当 this 的值为 null 或 undefined 时，该值不会转换为全局对象，比如：</p>

<pre><code class="javascript">    "use strict";
    function testFunc() {
        return this;
    }
    var testvar = testFunc();
</code></pre>

<p>在正常的模式下，testvar的值为全局对象，但在严格模式下，该值为 undefined。</p>

<p>再比如：</p>

<pre><code class="javascript">    function f(){
　　　　return !this;
　　}
　　// 返回false，因为"this"指向全局对象，"!this"就是false
　　function f(){
　　　　"use strict";
　　　　return !this;
　　}
　　// 返回true，因为严格模式下，this的值为undefined，所以"this"为true。
</code></pre>

<p>因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。</p>

<pre><code class="javascript">    function f(){
　　　　"use strict";
　　　　this.a = 1;
　　}
　　f();// 报错，this未定义
</code></pre>

<p>需要注意的是在IE10的PP2版（支持严格模式）中对于严格模式下得this存在bug，对于<code>(function(){ "use strict"; return !this })()</code>返回的是false。</p>

<ul>
<li><p>10、禁止“eval”用作标示符（变量、函数名、参数名等）</p></li>
<li><p>11、eval具有独立作用域</p></li>
</ul>


<p>正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。</p>

<pre><code class="javascript">    "use strict";
    var indirectEval = eval;
    indirectEval("var testvar = 10;");
    document.write(testVar);    // 报错，testVar未定义
</code></pre>

<ul>
<li>12、禁止在语句或块内声明函数</li>
</ul>


<p>严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数，否则将会报错：“SCRIPT1047：在严格模式下，函数声明无法嵌套在语句或块中。 它们只能显示在顶级或直接显示在函数体中。”</p>

<pre><code class="javascript">    "use strict";
    var arr = [1, 2, 3, 4, 5];
    var index = null;
    for (index in arr) {
        function myFunc() {};   // 报错
    }
</code></pre>

<ul>
<li><p>13、禁止“arguments”用作标示符（变量、函数名、参数名等）</p></li>
<li><p>14、禁止对arguments对象赋值</p></li>
<li><p>15、arguments不再影响和追踪参数值</p></li>
</ul>


<pre><code class="javascript">    function f(a) {
　　  "use strict";
　　  a++；
　　  return [a, arguments[0]];
　　 }
　　f(1); // [2,1]
　　
　　function f(a) {
　　  "use strict";
　　  arguments[0]++；
　　  return [a, arguments[0]];
　　 }
　　 f(1);    // [1,2]
</code></pre>

<p>在严格模式下，arguments对象只是一个本地副本。</p>

<ul>
<li>16、禁止使用arguments.callee</li>
</ul>


<pre><code class="javascript">    "use strict";
　　var f = function() { return arguments.callee; };
　　f(); // 报错
</code></pre>

<ul>
<li>17、禁止使用with</li>
</ul>


<pre><code class="javascript">    "use strict";
　　with (Math){
        x = cos(3);
        y = tan(7);
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GET和POST请求]]></title>
    <link href="http://wibud.github.io/blog/2013/08/05/gethe-postqing-qiu/"/>
    <updated>2013-08-05T11:12:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/08/05/gethe-postqing-qiu</id>
    <content type="html"><![CDATA[<h3>GET请求</h3>

<p>GET是最常见的请求类型，最常用于向服务器查询信息。如果要发送信息给服务器的话，需要将查询字符串参数追加到URL的末尾。</p>

<p>使用GET请求经常会发生一个错误，就是查询字符串参数的格式有问题。对于Javascript来说查询字符串中每个参数的名称和值都必须使用<code>encodeURIComponent()</code>进行编码，然后才能放到URL的末尾。</p>

<h3>POST请求</h3>

<p>POST通常用于向服务器发送应该被保存的数据。POST请求把数据作为请求的主体提交。POST请求的主体可以包含非常多的数据，而且格式不限。</p>

<h3>GET和POST的区别</h3>

<ul>
<li>GET只要是用来查询数据；POST主要用来提交数据</li>
<li>GET提交的数据是缀到URL末尾的，GET方式值发送HTTP消息头，没有消息体；POST的提交的数据是在消息体中</li>
<li>GET提交的数据量小，因为URL长度有限制；POST能提交大量数据</li>
<li>GET消耗的资源少；POST消耗的资源多</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cookie与session]]></title>
    <link href="http://wibud.github.io/blog/2013/08/03/cookieyu-session/"/>
    <updated>2013-08-03T11:11:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/08/03/cookieyu-session</id>
    <content type="html"><![CDATA[<h2>Cookie</h2>

<p>HTTP Cookie，通常直接叫做cookie，是在客户端用户存储会话信息的。cookie存储的信息是由服务器经HTTP头作为响应发给客户端的。例如服务器相应可能如下：</p>

<pre><code>HTTP/1.1 200 OK
Content-type:text/html
Set-Cookie:name=value
</code></pre>

<p>其中的<code>Set-Cookie</code>包含着会话信息，浏览器会存储这些会话信息，之后会为每个请求添加Cookie HTTP头，将信息发送回服务器，如下</p>

<pre><code>GET /index.html HTTP/1.1
Cookie:name=value
</code></pre>

<p>因为Cookie是存储在浏览器上，浏览器资源有限，所以Cookie的个数和大小会有限制，不同的浏览器对Cookie 的限制不同，有的限制每个域只能有20个Cookie，且每个域Cookie总大小限制在4095B，有的浏览器可能会多些。</p>

<h3>Cookie构成</h3>

<ul>
<li>名称：唯一确定cookie，名称是不区分大小写的</li>
<li>值：存储在cookie中的字符串的值，必须被URL编码</li>
<li>域：表示cookie对哪个域是有效的，所有向该有效域发送的请求都会加上这个cookie信息。如果没有设置，默认是设置cookie的域</li>
<li>路径：对于制定域中的那个路径，应该向服务器发送cookie</li>
<li>失效时间：表示cookie应该何时被删除。如果不设定，默认情况下，浏览器会话结束就会删除cookie（会话cookie）。如果设置了时间（大于当前时间），则浏览器关闭后cookie依然会保存在用户机器上（持久cookie）。这个值是GMT格式的日期。</li>
<li>安全标志</li>
</ul>


<h3>Javascript操作cookie</h3>

<p> <code>document.cookie</code>属性返回当前页面可用的（根据cookie的域、路径、失效时间和安全设置）所有cookie的字符串，一系列由分号分隔的名值对，如下：</p>

<pre><code>name1=value1;name2=value2;name3=value3
</code></pre>

<p>所有名字和值都是URL编码的，所以必须使用<code>decodeURIComponent()</code>解码。</p>

<p>设置值得时候，可以直接给<code>document.cookie</code>属性赋值，并不会覆盖cookie，除非设置的cookie名称已经存在。</p>

<p>由于cookie操作比较麻烦，并不直观，下面来看一个简化cookie操作的功能对象：</p>

<pre><code class="javascript">
    var CookieUtil={

        get: function(name){
            var cookieName = encodeURIComponent(name)+"=",
                cookieStart = document.cookie.indexof(cookieName);
                cookieValue = null;

            if(cookieStart &gt; -1){
                var cookieEnd = document.cookie.indexof(";",cookieStart);
                if(cookieEnd == -1){
                    cookieEnd = document.cookie.length;
                }
                cookieValue = decodeURIComponent(document.cookie.substring(cookieStart+cookieName.length, cookieEnd));
            }

            return cookieValue
        }

        set: function(name, value, expires, path, domain, secure){
            var cookieText = encodeURIComponent(name)+"="+encodeURIComponent(value);

            if(expires instanceof Date){
                cookieText += "; expires=" + expires.toGMTString();
            }

            if(path){
                cookieText += "; path=" + path;
            }

            if(domain){
                cookieText += "; domain=" + domain;
            }

            if(secure){
                cookieText += "; secure";
            }

            document.cookie = cookieText;
        }
    }
</code></pre>

<!-- more -->


<h2>Session</h2>

<p>Session机制是一种服务器端维持会话状态的机制。每个session唯一的由一个session id标示，session id是存储在客户端的，由客户端请求时发给服务器来与相应的session建立联系。</p>

<p>session id一般来说是保存在cookie中，当然如果cookie被禁用了，我们就需要其他的存储手段，比如：URL重写，就是把session id附加到URL路径的后面，还有一种技术叫表单隐藏字段，给表单添加一个隐藏字段。</p>

<h3>Session什么时候创建</h3>

<p>session是在服务器端程序调用HttpServletRequest.getSession(true)这样的语句时才被创建，而不是客户端访问的时候被创建的。</p>

<p>注意JSP如果没有显示的关闭session，会自动创建session。</p>

<h3>Session什么时候被删除</h3>

<ul>
<li>程序调用<code>HttpSession.invalidate()</code></li>
<li>session超时</li>
<li>服务器进程停止</li>
</ul>


<p>要注意的是session id一般是保存在会话cookie中，会话cookie会在浏览器关闭之后被删除，于是，相应的session id也会被删除，但是这时并不代表session也被删除了，服务器会一直保留session直到session处于非活动状态的时间超过了设置的超时时间，这时才会删除session。</p>

<h2>Cookie与Session的区别</h2>

<p>cookie机制采用的是在客户端保持状态的机制，cookie信息保存在客户端。cookie存储空间小。</p>

<p>session机制采用的是服务器端保持状态的机制，session信息保存在服务器端。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ajax相关总结]]></title>
    <link href="http://wibud.github.io/blog/2013/08/02/ajaxxiang-guan-zong-jie/"/>
    <updated>2013-08-02T11:09:00+08:00</updated>
    <id>http://wibud.github.io/blog/2013/08/02/ajaxxiang-guan-zong-jie</id>
    <content type="html"><![CDATA[<h3>创建XMLHttpRequest对象</h3>

<p>创建XMLHttpRequest对象，跨浏览器兼容：</p>

<pre><code class="javascript">
    function createXHR(){

        // 如果支持原生XHR对象
        if(typeof XMLHttpRequest != "undefined"){
            return new XMLHttpRequest();
        }
        // 兼容IE6和之前版本
        else if(typeof ActiveXObject != "undefined"){

            // arguments.callee.activeXString存放版本信息
            if(typeof arguments.callee.activeXString != "string"){

                // 可能有3中不同版本的XHR对象
                var versions = ["MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHttp"],
                    i,len;

                for(i=0, len=versions.length; i&lt;len; i++){

                    // 如果不能创建相应版本的XHR对象，会抛异常，继续检查下一个版本
                    try{
                        new ActiveXObject(versions[i]);
                        // 如果可以创建该版本的XHR对象，则记录版本
                        arguments.callee.activeXString = versions[i];
                        break;
                    }catch(ex){
                        // 没有操作
                    }
                }
            }

            return new ActiveXObject(arguments.callee.activeXString);
        }else{
            throw new Error("No XHR object available");
        }
    }
</code></pre>

<h3>响应处理</h3>

<pre><code class="javascript">
    var xhr = createXHR():
    // 必须在调用open()之前指定onreadystatechange事件处理才能确保跨浏览器的兼容性
    xhr.onreadystartechange = function(){
        // 请求/响应过程完成
        if(xhr.readyState == 4){
            if(httpSuccess(xhr)){
                // 响应的处理
            }else{
                // 请求/响应不成功
            }
        }
    };
    xhr.open("get", "example.txt", true);
    xhr.send(null);

    function httpSuccess(xhr){
        try{
            // 如果得不到服务器状态，且我们正在请求本地文件，认为成功
            return !xhr.status &amp;&amp; location.protocol=="file:" ||

                    // 所有200到300间的状态码表示成功（包括200，不包括300）
                    (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) ||

                    // 文档未修改也算成功
                    xhr.status == 304 ||

                    // Safari 在文档未修改时返回空状态
                    navigator.userAgent.indexof("Safari") &gt;= 0 &amp;&amp;
                        typeof xhr.status == "undefined";

        }catch(ex){}

        return false;
    }
</code></pre>

<!-- more -->


<h4>常见的status返回码</h4>

<ul>
<li>403:Access Forbidden。通常是服务器上文件或目录的权限设置导致</li>
<li>404：Object not found。请求资源不存在</li>
<li>401：Access Denied。由于用户匿名访问使用的账号被禁用，或者没有权限访问计算机。</li>
<li>500：Internal Server Error。服务器发生错误。</li>
</ul>


<h3>AJAX跨域请求（CORS）</h3>

<p>跨浏览器的CORS：</p>

<pre><code>function createCORSRequest(method, url){
    var xhr = new XMLHttpRequest();
    // 检测XHR是否支持CORS
    if("withCredentials" in xhr){
        xhr.open(method, url, true);

    // 准对IE（IE8及之后版本）
    }else if(typeof XDomainRequest != "undefined"){
        xhr = new XDomainRequest();
        xhr.open(method, url);
    }else{
        xhr = null;
    }
    return xhr;
}

var request = createCORSRequest("get", "http://www.test.com/index");
if(request){
    // 请求返回会触发load事件
    request.onload = function(){
        // 操作
    };

    request.send();
}
</code></pre>
]]></content>
  </entry>
  
</feed>
